test_tjc_init

# Test generation of code with "OPTIONS +inline-containers"

# Load jdk test data in case this has not already been done.
source [file join [tcltest::testsDirectory] jdkutils.tcl]
test_jdk_load_config

# Invoked after compileproc_init is invoked inside compileproc_compile.

proc test_compileproc_2_set_flags { proc_name } {
    global _compileproc
    global test_compileproc_2_set_flags_only
    global test_compileproc_2_expr_no_string_compare_optimizations

    set containers all
    if {[info exists test_compileproc_2_set_flags_only]} {
        set containers $test_compileproc_2_set_flags_only
        unset test_compileproc_2_set_flags_only
    }

    # Flag to disable expr string compare optimizations
    if {[info exists test_compileproc_2_expr_no_string_compare_optimizations]} {
        set _compileproc(options,expr_no_string_compare_optimizations) 1
        unset test_compileproc_2_expr_no_string_compare_optimizations
    }

    set _compileproc(options,inline_containers) $containers
}

tcltest::test compileproc2-1.0 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    if {1} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {1} {}
            if ( true ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-1.1 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    if {$var} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {$var} ...
            TclObject tmp0 = interp.getVar("var", null, 0);
            boolean tmp1 = TJC.getBoolean(interp, tmp0);
            if ( tmp1 ) {
                { // Invoke: cmd
                    TclObject[] objv2 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: cmd
                        tmp3 = const0;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 1);
                    }
                } // End Invoke: cmd
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-1.2 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    if {1<2} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit just the if and not the expr inside the if
    set test_compileproc_2_set_flags_only {if}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {1<2} {}
            { // Invoke: expr {1<2}
                TclObject[] objv0 = TJC.grabObjv(interp, 2);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: expr
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    // Arg 1 constant: {1<2}
                    tmp1 = const1;
                    tmp1.preserve();
                    objv0[1] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 2);
                }
            } // End Invoke: expr
            TclObject tmp2 = interp.getResult();
            boolean tmp3 = TJC.getBoolean(interp, tmp2);
            if ( tmp3 ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("expr");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("1<2");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-1.3 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    if {"1<2"} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit just the if and not the expr inside the if
    set test_compileproc_2_set_flags_only {if}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {"1<2"} {}
            { // Invoke: expr {"1<2"}
                TclObject[] objv0 = TJC.grabObjv(interp, 2);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: expr
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    // Arg 1 constant: {"1<2"}
                    tmp1 = const1;
                    tmp1.preserve();
                    objv0[1] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 2);
                }
            } // End Invoke: expr
            TclObject tmp2 = interp.getResult();
            boolean tmp3 = TJC.getBoolean(interp, tmp2);
            if ( tmp3 ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("expr");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("\"1<2\"");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-1.4 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    ::if {1} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: ::if {1} {}
            if ( true ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: ::if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-1.5 {compile proc into Java source, +inline-containers} {
    # This "+1" expression is not a constant boolean. A constant
    # boolean must be "1" or "true".
    set script {
proc p {} {
    if {+1} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {+1} {}
            // Unary operator: + 1
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
            // End Unary operator: +
            boolean tmp1 = tmp0.getBooleanValue(interp);
            TJC.exprReleaseValue(interp, tmp0);
            if ( tmp1 ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}


tcltest::test compileproc2-2.0 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    while {1} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: while {1} {}
            for ( boolean tmp0 = true ; tmp0 ; ) {
            }
            interp.resetResult();
        } // End Invoke: while
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-2.1 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    while {0} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: while {0} {}
            for ( boolean tmp0 = false ; tmp0 ; ) {
            }
            interp.resetResult();
        } // End Invoke: while
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-2.2 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    while {0} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: while {0} ...
            for ( boolean tmp0 = false ; tmp0 ; ) {
                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv1 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp2;
                        // Arg 0 constant: cmd
                        tmp2 = const0;
                        tmp2.preserve();
                        objv1[0] = tmp2;
                        TJC.invoke(interp, null, objv1, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv1, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: while
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-2.3 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    while {$var} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: while {$var} ...
            for ( ; true ; ) {
                TclObject tmp0 = interp.getVar("var", null, 0);
                boolean tmp1 = TJC.getBoolean(interp, tmp0);
                if ( ! tmp1 ) { break; }

                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv2 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: cmd
                        tmp3 = const0;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: while
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-2.4 {compile proc into Java source, +inline-containers} {
    # Invoke expr to handle expression
    set script {
proc p {} {
    while {[cmd1]} {
        cmd2
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit just the while and not the expr inside the while
    set test_compileproc_2_set_flags_only {while}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: while {[cmd1]} ...
            for ( ; true ; ) {
                { // Invoke: expr {[cmd1]}
                    TclObject[] objv0 = TJC.grabObjv(interp, 2);
                    try {
                        TclObject tmp1;
                        // Arg 0 constant: expr
                        tmp1 = const0;
                        tmp1.preserve();
                        objv0[0] = tmp1;
                        // Arg 1 constant: {[cmd1]}
                        tmp1 = const1;
                        tmp1.preserve();
                        objv0[1] = tmp1;
                        TJC.invoke(interp, null, objv0, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv0, 2);
                    }
                } // End Invoke: expr
                TclObject tmp2 = interp.getResult();
                boolean tmp3 = TJC.getBoolean(interp, tmp2);
                if ( ! tmp3 ) { break; }

                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd2
                    TclObject[] objv4 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp5;
                        // Arg 0 constant: cmd2
                        tmp5 = const2;
                        tmp5.preserve();
                        objv4[0] = tmp5;
                        TJC.invoke(interp, null, objv4, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv4, 1);
                    }
                } // End Invoke: cmd2
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: while
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("expr");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("[cmd1]");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("cmd2");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.0 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {0} {} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {0} {} ...
            for ( boolean tmp0 = false ; tmp0 ; ) {
                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv1 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp2;
                        // Arg 0 constant: cmd
                        tmp2 = const0;
                        tmp2.preserve();
                        objv1[0] = tmp2;
                        TJC.invoke(interp, null, objv1, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv1, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.1 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {1} {} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {1} {} {}
            for ( boolean tmp0 = true ; tmp0 ; ) {
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-3.2 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {1} {} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {1} {} ...
            for ( ; true ; ) {
                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv0 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp1;
                        // Arg 0 constant: cmd
                        tmp1 = const0;
                        tmp1.preserve();
                        objv0[0] = tmp1;
                        TJC.invoke(interp, null, objv0, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv0, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.3 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {$var} {} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {$var} {} ...
            for ( ; true ; ) {
                TclObject tmp0 = interp.getVar("var", null, 0);
                boolean tmp1 = TJC.getBoolean(interp, tmp0);
                if ( ! tmp1 ) { break; }

                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv2 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: cmd
                        tmp3 = const0;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.4 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {[cmd1]} {} {
        cmd2
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit just the for and not the expr inside the for
    set test_compileproc_2_set_flags_only {for}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {[cmd1]} {} ...
            for ( ; true ; ) {
                { // Invoke: expr {[cmd1]}
                    TclObject[] objv0 = TJC.grabObjv(interp, 2);
                    try {
                        TclObject tmp1;
                        // Arg 0 constant: expr
                        tmp1 = const0;
                        tmp1.preserve();
                        objv0[0] = tmp1;
                        // Arg 1 constant: {[cmd1]}
                        tmp1 = const1;
                        tmp1.preserve();
                        objv0[1] = tmp1;
                        TJC.invoke(interp, null, objv0, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv0, 2);
                    }
                } // End Invoke: expr
                TclObject tmp2 = interp.getResult();
                boolean tmp3 = TJC.getBoolean(interp, tmp2);
                if ( ! tmp3 ) { break; }

                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd2
                    TclObject[] objv4 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp5;
                        // Arg 0 constant: cmd2
                        tmp5 = const2;
                        tmp5.preserve();
                        objv4[0] = tmp5;
                        TJC.invoke(interp, null, objv4, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv4, 1);
                    }
                } // End Invoke: cmd2
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("expr");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("[cmd1]");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("cmd2");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.5 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {$i} {break} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {$i} {break} {}
            for ( boolean skip2 = true ; true ; ) {
                if ( skip2 ) {
                    skip2 = false;
                } else {
                    try {
                    if ( false ) { throw (TclException) null; }
                    { // Invoke: break
                        TclObject[] objv3 = TJC.grabObjv(interp, 1);
                        try {
                            TclObject tmp4;
                            // Arg 0 constant: break
                            tmp4 = const0;
                            tmp4.preserve();
                            objv3[0] = tmp4;
                            TJC.invoke(interp, null, objv3, 0);
                        } finally {
                            TJC.releaseObjvElems(interp, objv3, 1);
                        }
                    } // End Invoke: break
                    } catch (TclException ex) {
                        int type = ex.getCompletionCode();
                        if (type == TCL.BREAK) {
                            break;
                        } else {
                            throw ex;
                        }
                    }
                }

                TclObject tmp0 = interp.getVar("i", null, 0);
                boolean tmp1 = TJC.getBoolean(interp, tmp0);
                if ( ! tmp1 ) { break; }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("break");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.6 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {} {true} {break} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {} {true} {break} ...
            for ( boolean skip0 = true ; true ; ) {
                if ( skip0 ) {
                    skip0 = false;
                } else {
                    try {
                    if ( false ) { throw (TclException) null; }
                    { // Invoke: break
                        TclObject[] objv1 = TJC.grabObjv(interp, 1);
                        try {
                            TclObject tmp2;
                            // Arg 0 constant: break
                            tmp2 = const0;
                            tmp2.preserve();
                            objv1[0] = tmp2;
                            TJC.invoke(interp, null, objv1, 0);
                        } finally {
                            TJC.releaseObjvElems(interp, objv1, 1);
                        }
                    } // End Invoke: break
                    } catch (TclException ex) {
                        int type = ex.getCompletionCode();
                        if (type == TCL.BREAK) {
                            break;
                        } else {
                            throw ex;
                        }
                    }
                }

                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv3 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp4;
                        // Arg 0 constant: cmd
                        tmp4 = const1;
                        tmp4.preserve();
                        objv3[0] = tmp4;
                        TJC.invoke(interp, null, objv3, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv3, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("break");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("cmd");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-3.7 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    for {set i 0} {$i < 10} {incr i} {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit just the for and not the expr inside the for
    set test_compileproc_2_set_flags_only {for}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: for {set i 0} {$i < 10} {incr i} ...
            { // Invoke: set i 0
                TclObject[] objv0 = TJC.grabObjv(interp, 3);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: set
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    // Arg 1 constant: i
                    tmp1 = const1;
                    tmp1.preserve();
                    objv0[1] = tmp1;
                    // Arg 2 constant: 0
                    tmp1 = const2;
                    tmp1.preserve();
                    objv0[2] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 3);
                }
            } // End Invoke: set
            for ( boolean skip6 = true ; true ; ) {
                if ( skip6 ) {
                    skip6 = false;
                } else {
                    try {
                    if ( false ) { throw (TclException) null; }
                    { // Invoke: incr i
                        TclObject[] objv7 = TJC.grabObjv(interp, 2);
                        try {
                            TclObject tmp8;
                            // Arg 0 constant: incr
                            tmp8 = const5;
                            tmp8.preserve();
                            objv7[0] = tmp8;
                            // Arg 1 constant: i
                            tmp8 = const1;
                            tmp8.preserve();
                            objv7[1] = tmp8;
                            TJC.invoke(interp, null, objv7, 0);
                        } finally {
                            TJC.releaseObjvElems(interp, objv7, 2);
                        }
                    } // End Invoke: incr
                    } catch (TclException ex) {
                        int type = ex.getCompletionCode();
                        if (type == TCL.BREAK) {
                            break;
                        } else {
                            throw ex;
                        }
                    }
                }

                { // Invoke: expr {$i < 10}
                    TclObject[] objv2 = TJC.grabObjv(interp, 2);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: expr
                        tmp3 = const3;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        // Arg 1 constant: {$i < 10}
                        tmp3 = const4;
                        tmp3.preserve();
                        objv2[1] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 2);
                    }
                } // End Invoke: expr
                TclObject tmp4 = interp.getResult();
                boolean tmp5 = TJC.getBoolean(interp, tmp4);
                if ( ! tmp5 ) { break; }

                try {
                if ( false ) { throw (TclException) null; }
                { // Invoke: cmd
                    TclObject[] objv9 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp10;
                        // Arg 0 constant: cmd
                        tmp10 = const6;
                        tmp10.preserve();
                        objv9[0] = tmp10;
                        TJC.invoke(interp, null, objv9, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv9, 1);
                    }
                } // End Invoke: cmd
                } catch (TclException ex) {
                    int type = ex.getCompletionCode();
                    if (type == TCL.BREAK) {
                        break;
                    } else if (type == TCL.CONTINUE) {
                        continue;
                    } else {
                        throw ex;
                    }
                }
            }
            interp.resetResult();
        } // End Invoke: for
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;
    TclObject const3;
    TclObject const4;
    TclObject const5;
    TclObject const6;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("i");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(0);
        const2.preserve(); const2.preserve();
        const3 = TclString.newInstance("expr");
        const3.preserve(); const3.preserve();
        const4 = TclString.newInstance("$i < 10");
        const4.preserve(); const4.preserve();
        const5 = TclString.newInstance("incr");
        const5.preserve(); const5.preserve();
        const6 = TclString.newInstance("cmd");
        const6.preserve(); const6.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-4.0 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    catch {cmd}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {cmd}
            int code0 = TCL.OK;
            try {
            if ( false ) { throw (TclException) null; }
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            } catch (TclException ex) {
                code0 = ex.getCompletionCode();
            }
            interp.resetResult();
            interp.setResult(code0);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-4.1 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    catch {cmd} err
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {cmd} err
            int code0 = TCL.OK;
            try {
            if ( false ) { throw (TclException) null; }
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            } catch (TclException ex) {
                code0 = ex.getCompletionCode();
            }
            TclObject result = interp.getResult();
            try {
                interp.setVar("err", null, result, 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(code0);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-4.2 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    catch {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {}
            interp.resetResult();
            interp.setResult(TCL.OK);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-4.3 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    catch {} err
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {} err
            try {
                interp.setVar("err", null, "", 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(TCL.OK);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-4.4 {compile proc into Java source, +inline-containers} {
    # This catch command has a variable name that needs to
    # be evaluated at runtime.
    set script {
proc p {} {
    catch {cmd} $varname
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {cmd} $varname
            TclObject tmp0 = interp.getVar("varname", null, 0);
            String tmp1 = tmp0.toString();
            int code2 = TCL.OK;
            try {
            if ( false ) { throw (TclException) null; }
            { // Invoke: cmd
                TclObject[] objv3 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp4;
                    // Arg 0 constant: cmd
                    tmp4 = const0;
                    tmp4.preserve();
                    objv3[0] = tmp4;
                    TJC.invoke(interp, null, objv3, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv3, 1);
                }
            } // End Invoke: cmd
            } catch (TclException ex) {
                code2 = ex.getCompletionCode();
            }
            TclObject result = interp.getResult();
            try {
                interp.setVar(tmp1, null, result, 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(code2);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-4.5 {compile proc into Java source, +inline-containers} {
    # Set array variable with catch command
    set script {
proc p {} {
    catch {} a(e)
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {} a(e)
            try {
                interp.setVar("a", "e", "", 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(TCL.OK);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-4.6 {compile proc into Java source, +inline-containers} {
    # Set a non-static variable that is a word element.
    # The word element must be evaluated before
    # the commands in the catch block.
    set script {
proc p {} {
    catch {cmd} "var${s}"
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {cmd} "var${s}"
            TclObject tmp0;
            StringBuffer sbtmp1 = new StringBuffer(64);
            sbtmp1.append("var");
            tmp0 = interp.getVar("s", null, 0);
            sbtmp1.append(tmp0.toString());
            tmp0 = TclString.newInstance(sbtmp1);
            String tmp2 = tmp0.toString();
            int code3 = TCL.OK;
            try {
            if ( false ) { throw (TclException) null; }
            { // Invoke: cmd
                TclObject[] objv4 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp5;
                    // Arg 0 constant: cmd
                    tmp5 = const0;
                    tmp5.preserve();
                    objv4[0] = tmp5;
                    TJC.invoke(interp, null, objv4, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv4, 1);
                }
            } // End Invoke: cmd
            } catch (TclException ex) {
                code3 = ex.getCompletionCode();
            }
            TclObject result = interp.getResult();
            try {
                interp.setVar(tmp2, null, result, 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(code3);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-4.7 {compile proc into Java source, +inline-containers} {
    # Set a non-static variable that is a word element.
    # The word element must be evaluated before
    # the empty catch block.
    set script {
proc p {} {
    catch {} "var${s}"
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {} "var${s}"
            TclObject tmp0;
            StringBuffer sbtmp1 = new StringBuffer(64);
            sbtmp1.append("var");
            tmp0 = interp.getVar("s", null, 0);
            sbtmp1.append(tmp0.toString());
            tmp0 = TclString.newInstance(sbtmp1);
            String tmp2 = tmp0.toString();
            try {
                interp.setVar(tmp2, null, "", 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(TCL.OK);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-4.8 {compile proc into Java source, +inline-containers} {
    # Set non-static array variable with catch command.
    # The set var logic will notice when a varname is
    # an array with a non-static key and emit special
    # code that will skip the word evaluation, and
    # invoke the array variable set logic.
    set script {
proc p {} {
    catch {cmd} a($s)
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {cmd} a($s)
            TclObject tmp3 = interp.getVar("s", null, 0);
            String tmp4 = tmp3.toString();
            int code0 = TCL.OK;
            try {
            if ( false ) { throw (TclException) null; }
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            } catch (TclException ex) {
                code0 = ex.getCompletionCode();
            }
            TclObject result = interp.getResult();
            try {
            interp.setVar("a", tmp4, result, 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(code0);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-4.9 {compile proc into Java source, +inline-containers} {
    # Non-static var name with empty catch block.
    set script {
proc p {} {
    catch {} a($s)
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {} a($s)
            TclObject tmp0 = interp.getVar("s", null, 0);
            String tmp1 = tmp0.toString();
            try {
            interp.setVar("a", tmp1, "", 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(TCL.OK);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-4.10 {compile proc into Java source, +inline-containers} {
    # Non-static var name with empty catch block.
    # This example shows why the word element
    # need to be converted to a String, so the
    # result object does not get deallocated when
    # another command is run.
    set script {
proc p {} {
    catch {cmd} a([cmd])
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: catch {cmd} a([cmd])
            { // Invoke: cmd
                TclObject[] objv5 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp6;
                    // Arg 0 constant: cmd
                    tmp6 = const0;
                    tmp6.preserve();
                    objv5[0] = tmp6;
                    TJC.invoke(interp, null, objv5, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv5, 1);
                }
            } // End Invoke: cmd
            TclObject tmp3 = interp.getResult();
            String tmp4 = tmp3.toString();
            int code0 = TCL.OK;
            try {
            if ( false ) { throw (TclException) null; }
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            } catch (TclException ex) {
                code0 = ex.getCompletionCode();
            }
            TclObject result = interp.getResult();
            try {
            interp.setVar("a", tmp4, result, 0);
            } catch (TclException ex) {
                TJC.catchVarErr(interp);
            }
            interp.resetResult();
            interp.setResult(code0);
        } // End Invoke: catch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}


tcltest::test compileproc2-5.0 {compile proc into Java source, +inline-containers} {
    # Constant list, single varname
    set script {
proc p {} {
    foreach elem {1 2 3} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach elem {1 2 3} {}
            TclObject tmp0 = null;
            try {
                tmp0 = const0;
                tmp0.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);

                for ( int index1 = 0 ; index1 < tmp0_length ; index1++ ) {
                    TclObject tmp2 = TclList.index(interp, tmp0, index1);
                    try {
                        interp.setVar("elem", null, tmp2, 0);
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "elem");
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("1 2 3");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.1 {compile proc into Java source, +inline-containers} {
    # Variable list, single varname
    set script {
proc p {} {
    foreach elem $l {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach elem $l {}
            TclObject tmp0 = null;
            try {
                tmp0 = interp.getVar("l", null, 0);
                tmp0.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);

                for ( int index1 = 0 ; index1 < tmp0_length ; index1++ ) {
                    TclObject tmp2 = TclList.index(interp, tmp0, index1);
                    try {
                        interp.setVar("elem", null, tmp2, 0);
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "elem");
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-5.2 {compile proc into Java source, +inline-containers} {
    # Command list, single varname, single command
    set script {
proc p {} {
    foreach elem [cmd1] {
        cmd2
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach elem [...] ...
            TclObject tmp0 = null;
            try {
                { // Invoke: cmd1
                    TclObject[] objv1 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp2;
                        // Arg 0 constant: cmd1
                        tmp2 = const0;
                        tmp2.preserve();
                        objv1[0] = tmp2;
                        TJC.invoke(interp, null, objv1, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv1, 1);
                    }
                } // End Invoke: cmd1
                tmp0 = interp.getResult();
                tmp0.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);

                for ( int index3 = 0 ; index3 < tmp0_length ; index3++ ) {
                    TclObject tmp4 = TclList.index(interp, tmp0, index3);
                    try {
                        interp.setVar("elem", null, tmp4, 0);
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "elem");
                    }

                    try {
                    if ( false ) { throw (TclException) null; }
                    { // Invoke: cmd2
                        TclObject[] objv5 = TJC.grabObjv(interp, 1);
                        try {
                            TclObject tmp6;
                            // Arg 0 constant: cmd2
                            tmp6 = const1;
                            tmp6.preserve();
                            objv5[0] = tmp6;
                            TJC.invoke(interp, null, objv5, 0);
                        } finally {
                            TJC.releaseObjvElems(interp, objv5, 1);
                        }
                    } // End Invoke: cmd2
                    } catch (TclException ex) {
                        int type = ex.getCompletionCode();
                        if (type == TCL.BREAK) {
                            break;
                        } else if (type == TCL.CONTINUE) {
                            continue;
                        } else {
                            throw ex;
                        }
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd1");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("cmd2");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.3 {compile proc into Java source, +inline-containers} {
    # Constant list, two variables
    set script {
proc p {} {
    foreach {e1 e2} {1 2 3 4} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach {e1 e2} {1 2 3 4} {}
            TclObject tmp0 = null;
            try {
                tmp0 = const0;
                tmp0.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);

                for ( int index1 = 0 ; index1 < tmp0_length ; index1 += 2 ) {
                    TclObject tmp2 = null;
                    if ( index1 < tmp0_length ) {
                        tmp2 = TclList.index(interp, tmp0, index1);
                    }
                    TclObject tmp3 = null;
                    if ( index1 + 1 < tmp0_length ) {
                        tmp3 = TclList.index(interp, tmp0, index1 + 1);
                    }
                    try {
                        if ( tmp2 == null ) {
                            interp.setVar("e1", null, "", 0);
                        } else {
                            interp.setVar("e1", null, tmp2, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e1");
                    }
                    try {
                        if ( tmp3 == null ) {
                            interp.setVar("e2", null, "", 0);
                        } else {
                            interp.setVar("e2", null, tmp3, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e2");
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("1 2 3 4");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.4 {compile proc into Java source, +inline-containers} {
    # Two lists, one variable and two variables.
    set script {
proc p {} {
    foreach e1 {1 2} {e2 e3} {3 4 5 6 7 8} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach e1 {1 2} {e2 e3} {3 4 5 6 7 8} {}
            TclObject tmp0 = null;
            TclObject tmp1 = null;
            try {
                tmp0 = const0;
                tmp0.preserve();
                tmp1 = const1;
                tmp1.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);
                final int tmp1_length = TclList.getLength(interp, tmp1);
                int num_loops2, max_loops3 = 0;
                num_loops2 = tmp0_length;
                if ( num_loops2 > max_loops3 ) {
                    max_loops3 = num_loops2;
                }
                num_loops2 = (tmp1_length + 2 - 1) / 2;
                if ( num_loops2 > max_loops3 ) {
                    max_loops3 = num_loops2;
                }

                for ( int index4 = 0 ; index4 < max_loops3 ; index4++ ) {
                    int tmp1_index = index4 * 2;
                    TclObject tmp5 = null;
                    if ( index4 < tmp0_length ) {
                        tmp5 = TclList.index(interp, tmp0, index4);
                    }
                    TclObject tmp6 = null;
                    if ( tmp1_index < tmp1_length ) {
                        tmp6 = TclList.index(interp, tmp1, tmp1_index);
                    }
                    TclObject tmp7 = null;
                    if ( tmp1_index + 1 < tmp1_length ) {
                        tmp7 = TclList.index(interp, tmp1, tmp1_index + 1);
                    }
                    try {
                        if ( tmp5 == null ) {
                            interp.setVar("e1", null, "", 0);
                        } else {
                            interp.setVar("e1", null, tmp5, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e1");
                    }
                    try {
                        if ( tmp6 == null ) {
                            interp.setVar("e2", null, "", 0);
                        } else {
                            interp.setVar("e2", null, tmp6, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e2");
                    }
                    try {
                        if ( tmp7 == null ) {
                            interp.setVar("e3", null, "", 0);
                        } else {
                            interp.setVar("e3", null, tmp7, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e3");
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
                if ( tmp1 != null ) {
                    tmp1.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("1 2");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("3 4 5 6 7 8");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.5 {compile proc into Java source, +inline-containers} {
    # Two lists that are the same constant value
    set script {
proc p {} {
    foreach e1 {1 2} e2 {1 2} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach e1 {1 2} e2 {1 2} {}
            TclObject tmp0 = null;
            TclObject tmp1 = null;
            try {
                tmp0 = const0;
                tmp0.preserve();
                tmp1 = const0;
                tmp1.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);
                final int tmp1_length = TclList.getLength(interp, tmp1);
                int num_loops2, max_loops3 = 0;
                num_loops2 = tmp0_length;
                if ( num_loops2 > max_loops3 ) {
                    max_loops3 = num_loops2;
                }
                num_loops2 = tmp1_length;
                if ( num_loops2 > max_loops3 ) {
                    max_loops3 = num_loops2;
                }

                for ( int index4 = 0 ; index4 < max_loops3 ; index4++ ) {
                    TclObject tmp5 = null;
                    if ( index4 < tmp0_length ) {
                        tmp5 = TclList.index(interp, tmp0, index4);
                    }
                    TclObject tmp6 = null;
                    if ( index4 < tmp1_length ) {
                        tmp6 = TclList.index(interp, tmp1, index4);
                    }
                    try {
                        if ( tmp5 == null ) {
                            interp.setVar("e1", null, "", 0);
                        } else {
                            interp.setVar("e1", null, tmp5, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e1");
                    }
                    try {
                        if ( tmp6 == null ) {
                            interp.setVar("e2", null, "", 0);
                        } else {
                            interp.setVar("e2", null, tmp6, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e2");
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
                if ( tmp1 != null ) {
                    tmp1.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("1 2");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.6 {compile proc into Java source, +inline-containers} {
    # Two lists that are the result of command evaluations
    set script {
proc p {} {
    foreach e1 [cmd] e2 [cmd] {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach e1 [...] e2 [...] {}
            TclObject tmp0 = null;
            TclObject tmp1 = null;
            try {
                { // Invoke: cmd
                    TclObject[] objv2 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: cmd
                        tmp3 = const0;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 1);
                    }
                } // End Invoke: cmd
                tmp0 = interp.getResult();
                tmp0.preserve();
                { // Invoke: cmd
                    TclObject[] objv4 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp5;
                        // Arg 0 constant: cmd
                        tmp5 = const0;
                        tmp5.preserve();
                        objv4[0] = tmp5;
                        TJC.invoke(interp, null, objv4, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv4, 1);
                    }
                } // End Invoke: cmd
                tmp1 = interp.getResult();
                tmp1.preserve();
                final int tmp0_length = TclList.getLength(interp, tmp0);
                final int tmp1_length = TclList.getLength(interp, tmp1);
                int num_loops6, max_loops7 = 0;
                num_loops6 = tmp0_length;
                if ( num_loops6 > max_loops7 ) {
                    max_loops7 = num_loops6;
                }
                num_loops6 = tmp1_length;
                if ( num_loops6 > max_loops7 ) {
                    max_loops7 = num_loops6;
                }

                for ( int index8 = 0 ; index8 < max_loops7 ; index8++ ) {
                    TclObject tmp9 = null;
                    if ( index8 < tmp0_length ) {
                        tmp9 = TclList.index(interp, tmp0, index8);
                    }
                    TclObject tmp10 = null;
                    if ( index8 < tmp1_length ) {
                        tmp10 = TclList.index(interp, tmp1, index8);
                    }
                    try {
                        if ( tmp9 == null ) {
                            interp.setVar("e1", null, "", 0);
                        } else {
                            interp.setVar("e1", null, tmp9, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e1");
                    }
                    try {
                        if ( tmp10 == null ) {
                            interp.setVar("e2", null, "", 0);
                        } else {
                            interp.setVar("e2", null, tmp10, 0);
                        }
                    } catch (TclException ex) {
                        TJC.foreachVarErr(interp, "e2");
                    }
                }
                interp.resetResult();
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
                if ( tmp1 != null ) {
                    tmp1.release();
                }
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.7 {compile proc into Java source, +inline-containers} {
    # Non-constant variable name can't be inlined
    set script {
proc p {} {
    foreach $elem {1 2 3} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach $elem {1 2 3} {}
            TclObject[] objv0 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp1;
                // Arg 0 constant: foreach
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 variable: $elem
                tmp1 = interp.getVar("elem", null, 0);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: {1 2 3}
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                // Arg 3 constant: {}
                tmp1 = const2;
                tmp1.preserve();
                objv0[3] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 4);
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("foreach");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("1 2 3");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-5.8 {compile proc into Java source, +inline-containers} {
    # Non-constant variable name can't be inlined, this is
    # actually an array name, but this usage is documented
    # as unsupported and very slow.
    set script {
proc p {} {
    foreach a($k) {1 2 3} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: foreach a($k) {1 2 3} {}
            TclObject[] objv0 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp1;
                // Arg 0 constant: foreach
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 word: a($k)
                StringBuffer sbtmp2 = new StringBuffer(64);
                sbtmp2.append("a(");
                tmp1 = interp.getVar("k", null, 0);
                sbtmp2.append(tmp1.toString());
                sbtmp2.append(")");
                tmp1 = TclString.newInstance(sbtmp2);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: {1 2 3}
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                // Arg 3 constant: {}
                tmp1 = const2;
                tmp1.preserve();
                objv0[3] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 4);
            }
        } // End Invoke: foreach
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("foreach");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("1 2 3");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}



tcltest::test compileproc2-6.0 {compile proc into Java source, +inline-containers} {
    # mode flags, constant string, patbody list
    set script {
proc p {} {
    switch -exact -- Foo {
        Foo {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -exact -- Foo {Foo} {}
            String tmp0 = const0.toString();
            int tmp1;
            TclObject[] objv2 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp3;
                // Pattern {Foo}
                tmp3 = const0;
                tmp3.preserve();
                objv2[0] = tmp3;
                tmp1 = TJC.invokeSwitch(interp, objv2, 0,
                    tmp0, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 2);
            }
            interp.resetResult();
            if ( tmp1 == -1 ) {
                // No match
            } else if ( tmp1 == 1 ) {
                // Pattern {Foo}
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp1));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-6.1 {compile proc into Java source, +inline-containers} {
    # option terminator, variable string, patbody list
    set script {
proc p {} {
    switch -- $str {
        Foo {}
        Bar {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $str {Foo} {} {Bar} {}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp4;
                // Pattern {Foo}
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                // Pattern {Bar}
                tmp4 = const1;
                tmp4.preserve();
                objv3[2] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 4);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 1 ) {
                // Pattern {Foo}
            } else if ( tmp2 == 3 ) {
                // Pattern {Bar}
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("Bar");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-6.2 {compile proc into Java source, +inline-containers} {
    # no options, variable string, patbody list
    set script {
proc p {} {
    switch $str {
        Foo {}
        Bar {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch $str {Foo} {} {Bar} {}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            TJC.switchStringIsNotOption(interp, tmp1);
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp4;
                // Pattern {Foo}
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                // Pattern {Bar}
                tmp4 = const1;
                tmp4.preserve();
                objv3[2] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 4);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 1 ) {
                // Pattern {Foo}
            } else if ( tmp2 == 3 ) {
                // Pattern {Bar}
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("Bar");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-6.3 {compile proc into Java source, +inline-containers} {
    # mode flags, command string, patbody list
    set script {
proc p {} {
    switch -glob [getstr] {
        Fo* {}
        Ba* {}
        Ca* {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -glob [...] {Fo*} {} {Ba*} {} {Ca*} {}
            { // Invoke: getstr
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: getstr
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: getstr
            TclObject tmp0 = interp.getResult();
            String tmp3 = tmp0.toString();
            TJC.switchStringIsNotOption(interp, tmp3);
            int tmp4;
            TclObject[] objv5 = TJC.grabObjv(interp, 6);
            try {
                TclObject tmp6;
                // Pattern {Fo*}
                tmp6 = const1;
                tmp6.preserve();
                objv5[0] = tmp6;
                // Pattern {Ba*}
                tmp6 = const2;
                tmp6.preserve();
                objv5[2] = tmp6;
                // Pattern {Ca*}
                tmp6 = const3;
                tmp6.preserve();
                objv5[4] = tmp6;
                tmp4 = TJC.invokeSwitch(interp, objv5, 0,
                    tmp3, TJC.SWITCH_MODE_GLOB);
            } finally {
                TJC.releaseObjvElems(interp, objv5, 6);
            }
            interp.resetResult();
            if ( tmp4 == -1 ) {
                // No match
            } else if ( tmp4 == 1 ) {
                // Pattern {Fo*}
            } else if ( tmp4 == 3 ) {
                // Pattern {Ba*}
            } else if ( tmp4 == 5 ) {
                // Pattern {Ca*}
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp4));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;
    TclObject const3;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("getstr");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("Fo*");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("Ba*");
        const2.preserve(); const2.preserve();
        const3 = TclString.newInstance("Ca*");
        const3.preserve(); const3.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-6.4 {compile proc into Java source, +inline-containers} {
    # mode flags, word string, patbody list with command
    set script {
proc p {} {
    switch -regexp -- "$s" {
        .* {
            cmd
        }
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -regexp -- "$s" {.*} ...
            TclObject tmp0 = interp.getVar("s", null, 0);
            String tmp1 = tmp0.toString();
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp4;
                // Pattern {.*}
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_REGEXP);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 2);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 1 ) {
                // Pattern {.*}
                { // Invoke: cmd
                    TclObject[] objv5 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp6;
                        // Arg 0 constant: cmd
                        tmp6 = const1;
                        tmp6.preserve();
                        objv5[0] = tmp6;
                        TJC.invoke(interp, null, objv5, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv5, 1);
                    }
                } // End Invoke: cmd
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance(".*");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("cmd");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-6.5 {compile proc into Java source, +inline-containers} {
    # option terminator, variable string, patbody list, fallthrough body
    set script {
proc p {} {
    switch -- $str {
        Foo -
        Bar {cmd}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $str {Foo} - {Bar} {cmd}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp4;
                // Pattern {Foo}
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                // - fallthrough
                tmp4 = const1;
                tmp4.preserve();
                objv3[1] = tmp4;
                // Pattern {Bar}
                tmp4 = const2;
                tmp4.preserve();
                objv3[2] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 4);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 3 ) {
                // Pattern {Bar}
                { // Invoke: cmd
                    TclObject[] objv5 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp6;
                        // Arg 0 constant: cmd
                        tmp6 = const3;
                        tmp6.preserve();
                        objv5[0] = tmp6;
                        TJC.invoke(interp, null, objv5, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv5, 1);
                    }
                } // End Invoke: cmd
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;
    TclObject const3;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("-");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("Bar");
        const2.preserve(); const2.preserve();
        const3 = TclString.newInstance("cmd");
        const3.preserve(); const3.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-6.6 {compile proc into Java source, +inline-containers} {
    # no options, variable string, patbody list, multiple commands
    set script {
proc p {} {
    switch $str {
        Foo {cmd1;cmd2}
        Bar {cmd3}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch $str {Foo} {cmd1;cmd2} {Bar} {cmd3}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            TJC.switchStringIsNotOption(interp, tmp1);
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp4;
                // Pattern {Foo}
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                // Pattern {Bar}
                tmp4 = const1;
                tmp4.preserve();
                objv3[2] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 4);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 1 ) {
                // Pattern {Foo}
                { // Invoke: cmd1
                    TclObject[] objv5 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp6;
                        // Arg 0 constant: cmd1
                        tmp6 = const2;
                        tmp6.preserve();
                        objv5[0] = tmp6;
                        TJC.invoke(interp, null, objv5, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv5, 1);
                    }
                } // End Invoke: cmd1
                { // Invoke: cmd2
                    TclObject[] objv7 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp8;
                        // Arg 0 constant: cmd2
                        tmp8 = const3;
                        tmp8.preserve();
                        objv7[0] = tmp8;
                        TJC.invoke(interp, null, objv7, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv7, 1);
                    }
                } // End Invoke: cmd2
            } else if ( tmp2 == 3 ) {
                // Pattern {Bar}
                { // Invoke: cmd3
                    TclObject[] objv9 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp10;
                        // Arg 0 constant: cmd3
                        tmp10 = const4;
                        tmp10.preserve();
                        objv9[0] = tmp10;
                        TJC.invoke(interp, null, objv9, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv9, 1);
                    }
                } // End Invoke: cmd3
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;
    TclObject const3;
    TclObject const4;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("Bar");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("cmd1");
        const2.preserve(); const2.preserve();
        const3 = TclString.newInstance("cmd2");
        const3.preserve(); const3.preserve();
        const4 = TclString.newInstance("cmd3");
        const4.preserve(); const4.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-7.0 {compile proc into Java source, +inline-containers} {
    # mode flags, constant string, pattern body arguments
    set script {
proc p {} {
    switch -exact -- Foo Foo {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -exact -- Foo Foo {}
            String tmp0 = const0.toString();
            int tmp1;
            TclObject[] objv2 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp3;
                // Pattern Foo
                tmp3 = const0;
                tmp3.preserve();
                objv2[0] = tmp3;
                tmp1 = TJC.invokeSwitch(interp, objv2, 0,
                    tmp0, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 2);
            }
            interp.resetResult();
            if ( tmp1 == -1 ) {
                // No match
            } else if ( tmp1 == 1 ) {
                // Pattern Foo
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp1));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-7.1 {compile proc into Java source, +inline-containers} {
    # mode flags, variable string, pattern body arguments
    set script {
proc p {} {
    switch -exact -- $s Foo {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -exact -- $s Foo {}
            TclObject tmp0 = interp.getVar("s", null, 0);
            String tmp1 = tmp0.toString();
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp4;
                // Pattern Foo
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 2);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 1 ) {
                // Pattern Foo
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-7.2 {compile proc into Java source, +inline-containers} {
    # terminator flag, variable string, pattern body arguments
    set script {
proc p {} {
    switch -- $s Foo {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $s Foo {}
            TclObject tmp0 = interp.getVar("s", null, 0);
            String tmp1 = tmp0.toString();
            int tmp2;
            TclObject[] objv3 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp4;
                // Pattern Foo
                tmp4 = const0;
                tmp4.preserve();
                objv3[0] = tmp4;
                tmp2 = TJC.invokeSwitch(interp, objv3, 0,
                    tmp1, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv3, 2);
            }
            interp.resetResult();
            if ( tmp2 == -1 ) {
                // No match
            } else if ( tmp2 == 1 ) {
                // Pattern Foo
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp2));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-7.3 {compile proc into Java source, +inline-containers} {
    # variable string, pattern body arguments, this is not
    # statically defined because the argument needs to
    # be examined at runtime to determine which version
    # of the switch command this is.
    #
    # switch $string PATTERN BODY
    # or
    # switch $option $string PATLIST

    set script {
proc p {} {
    switch $s Foo {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch $s Foo {}
            TclObject[] objv0 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp1;
                // Arg 0 constant: switch
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 variable: $s
                tmp1 = interp.getVar("s", null, 0);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: Foo
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                // Arg 3 constant: {}
                tmp1 = const2;
                tmp1.preserve();
                objv0[3] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 4);
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("switch");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("Foo");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-7.4 {compile proc into Java source, +inline-containers} {
    # mode flags, constant string, variable and command pattern strings
    set script {
proc p {} {
    switch -exact -- Foo $pat {} [cmd] {} [cmd] {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    # Emit switch call but don't emit special code
    # for inlined constant string values.
    set test_compileproc_2_set_flags_only {switch switch_no_constant_strings}
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -exact -- Foo $pat {} [...] {} [...] {}
            String tmp0 = const0.toString();
            int tmp1;
            TclObject[] objv2 = TJC.grabObjv(interp, 6);
            try {
                TclObject tmp3;
                // Pattern $pat
                tmp3 = interp.getVar("pat", null, 0);
                tmp3.preserve();
                objv2[0] = tmp3;
                // Pattern [...]
                { // Invoke: cmd
                    TclObject[] objv4 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp5;
                        // Arg 0 constant: cmd
                        tmp5 = const1;
                        tmp5.preserve();
                        objv4[0] = tmp5;
                        TJC.invoke(interp, null, objv4, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv4, 1);
                    }
                } // End Invoke: cmd
                tmp3 = interp.getResult();
                tmp3.preserve();
                objv2[2] = tmp3;
                // Pattern [...]
                { // Invoke: cmd
                    TclObject[] objv6 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp7;
                        // Arg 0 constant: cmd
                        tmp7 = const1;
                        tmp7.preserve();
                        objv6[0] = tmp7;
                        TJC.invoke(interp, null, objv6, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv6, 1);
                    }
                } // End Invoke: cmd
                tmp3 = interp.getResult();
                tmp3.preserve();
                objv2[4] = tmp3;
                tmp1 = TJC.invokeSwitch(interp, objv2, 0,
                    tmp0, TJC.SWITCH_MODE_EXACT);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 6);
            }
            interp.resetResult();
            if ( tmp1 == -1 ) {
                // No match
            } else if ( tmp1 == 1 ) {
                // Pattern $pat
            } else if ( tmp1 == 3 ) {
                // Pattern [...]
            } else if ( tmp1 == 5 ) {
                // Pattern [...]
            } else {
                throw new TclRuntimeError("bad switch body offset " +
                    String.valueOf(tmp1));
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("Foo");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("cmd");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-8.0 {compile proc into Java source, +inline-containers} {
    # exact mode and all pattern arguments that are constant strings.
    set script {
proc p {} {
    switch -- $str {
        Foo {}
        Bar {}
        Bats {}
        "" {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $str {Foo} {} {Bar} {} {Bats} {} {} {}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            int tmp1_length = tmp1.length();
            char tmp1_first = '\n';
            if ( tmp1_length > 0 ) {
                tmp1_first = tmp1.charAt(0);
            }
            interp.resetResult();
            if ( tmp1_length == 3 && tmp1_first == 'F'
                    && tmp1.compareTo("Foo") == 0 ) {
                // Pattern {Foo}
            } else if ( tmp1_length == 3 && tmp1_first == 'B'
                    && tmp1.compareTo("Bar") == 0 ) {
                // Pattern {Bar}
            } else if ( tmp1_length == 4 && tmp1_first == 'B'
                    && tmp1.compareTo("Bats") == 0 ) {
                // Pattern {Bats}
            } else if ( tmp1_length == 0 ) {
                // Pattern {}
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-8.1 {compile proc into Java source, +inline-containers} {
    # exact mode and all pattern arguments that are constant strings.
    set script {
proc p {} {
    switch -- $str {
        Foo -
        Bar -
        Bats {}
        "" {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $str {Foo} - {Bar} - {Bats} {} {} {}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            int tmp1_length = tmp1.length();
            char tmp1_first = '\n';
            if ( tmp1_length > 0 ) {
                tmp1_first = tmp1.charAt(0);
            }
            interp.resetResult();
            if ( ( tmp1_length == 3 && tmp1_first == 'F'
                    && tmp1.compareTo("Foo") == 0 ) ||
                ( tmp1_length == 3 && tmp1_first == 'B'
                    && tmp1.compareTo("Bar") == 0 ) ||
                ( tmp1_length == 4 && tmp1_first == 'B'
                    && tmp1.compareTo("Bats") == 0 ) ) {
                // Pattern {Bats}
            } else if ( tmp1_length == 0 ) {
                // Pattern {}
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-8.2 {compile proc into Java source, +inline-containers} {
    # exact mode and all pattern arguments that are constant strings.
    set script {
proc p {} {
    switch -- $str {
        Foo {}
        Bar {}
        default {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $str {Foo} {} {Bar} {} default {}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            int tmp1_length = tmp1.length();
            char tmp1_first = '\n';
            if ( tmp1_length > 0 ) {
                tmp1_first = tmp1.charAt(0);
            }
            interp.resetResult();
            if ( tmp1_length == 3 && tmp1_first == 'F'
                    && tmp1.compareTo("Foo") == 0 ) {
                // Pattern {Foo}
            } else if ( tmp1_length == 3 && tmp1_first == 'B'
                    && tmp1.compareTo("Bar") == 0 ) {
                // Pattern {Bar}
            } else {
                // Pattern default
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-8.3 {compile proc into Java source, +inline-containers} {
    # exact mode and all pattern arguments that are constant strings.
    set script {
proc p {} {
    switch -- $str {
        Foo -
        Bar -
        {} -
        default {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- $str {Foo} - {Bar} - {} - default {}
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            int tmp1_length = tmp1.length();
            char tmp1_first = '\n';
            if ( tmp1_length > 0 ) {
                tmp1_first = tmp1.charAt(0);
            }
            interp.resetResult();
            if ( true ) {
                // Pattern default
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-8.4 {compile proc into Java source, +inline-containers} {
    # proper escape processing and single character strings
    set script {
proc p {} {
    switch -- {\$} {
        \$ {}
        {\$} {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- ... ... {} ... {}
            String tmp0 = const0.toString();
            int tmp0_length = tmp0.length();
            char tmp0_first = '\n';
            if ( tmp0_length > 0 ) {
                tmp0_first = tmp0.charAt(0);
            }
            interp.resetResult();
            if ( tmp0_length == 1 && tmp0_first == '$' ) {
                // Pattern ...
            } else if ( tmp0_length == 2 && tmp0_first == '\\'
                    && tmp0.compareTo("\\$") == 0 ) {
                // Pattern ...
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("\\$");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-8.4 {compile proc into Java source, +inline-containers} {
    # proper escape processing and multiple character strings
    # Note that the \$[cmd] pattern is interpreted as "\$\[cmd\]"
    set script {
proc p {} {
    switch -- {$[cmd]} {
        \$[cmd] {}
        {$[cmd]} {}
        {\$[cmd]} {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- {$[cmd]} ... {} {$[cmd]} {} ... {}
            String tmp0 = const0.toString();
            int tmp0_length = tmp0.length();
            char tmp0_first = '\n';
            if ( tmp0_length > 0 ) {
                tmp0_first = tmp0.charAt(0);
            }
            interp.resetResult();
            if ( tmp0_length == 6 && tmp0_first == '$'
                    && tmp0.compareTo("$[cmd]") == 0 ) {
                // Pattern ...
            } else if ( tmp0_length == 6 && tmp0_first == '$'
                    && tmp0.compareTo("$[cmd]") == 0 ) {
                // Pattern {$[cmd]}
            } else if ( tmp0_length == 7 && tmp0_first == '\\'
                    && tmp0.compareTo("\\$[cmd]") == 0 ) {
                // Pattern ...
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("$[cmd]");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-8.6 {compile proc into Java source, +inline-containers} {
    # proper escape processing
    set script {
proc p {} {
    switch -- {\t} {
        \t {}
        \u0009 {}
        \x09\n {}
        {\t} {}
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: switch -- ... ... {} ... {} ... {} ... {}
            String tmp0 = const0.toString();
            int tmp0_length = tmp0.length();
            char tmp0_first = '\n';
            if ( tmp0_length > 0 ) {
                tmp0_first = tmp0.charAt(0);
            }
            interp.resetResult();
            if ( tmp0_length == 1 && tmp0_first == '\t' ) {
                // Pattern ...
            } else if ( tmp0_length == 1 && tmp0_first == '\u0009' ) {
                // Pattern ...
            } else if ( tmp0_length == 2 && tmp0_first == '\u0009'
                    && tmp0.compareTo("\u0009\n") == 0 ) {
                // Pattern ...
            } else if ( tmp0_length == 2 && tmp0_first == '\\'
                    && tmp0.compareTo("\\t") == 0 ) {
                // Pattern ...
            }
        } // End Invoke: switch
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("\\t");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}


tcltest::test compileproc2-9.0 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {true}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {true}
            ExprValue tmp0 = TJC.exprGetValue(interp, "true");
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.1 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {$v}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$v}
            TclObject tmp0 = interp.getVar("v", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.2 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {!1}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {!1}
            // Unary operator: ! 1
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp0);
            // End Unary operator: !
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.3 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {1 + 2}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1 + 2}
            // Binary operator: 1 + 2
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
            ExprValue tmp1 = TJC.exprGetValue(interp, 2, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.4 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {" 1" - 1.0}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {" 1" - 1.0}
            // Binary operator: 1 - 1.0
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, " 1");
            ExprValue tmp1 = TJC.exprGetValue(interp, 1.0, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MINUS, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: -
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.5 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {"one" == $a(k)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set test_compileproc_2_expr_no_string_compare_optimizations 1
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {"one" == $a(k)}
            // Binary operator: "one" == $a(...)
            ExprValue tmp0 = TJC.exprGetValue(interp, "one");
            TclObject tmp1 = interp.getVar("a", "k", 0);
            ExprValue tmp2 = TJC.exprGetValue(interp, tmp1);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.6 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {1 + 2 - 3}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {1 + 2 - 3}
            // Binary operator: () - 3
            // Binary operator: 1 + 2
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
            ExprValue tmp1 = TJC.exprGetValue(interp, 2, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: +
            ExprValue tmp2 = TJC.exprGetValue(interp, 3, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MINUS, tmp0, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
            // End Binary operator: -
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.7 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {3 * (1 + 2)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {3 * (1 + 2)}
            // Binary operator: 3 * ()
            ExprValue tmp0 = TJC.exprGetValue(interp, 3, null);
            // Binary operator: 1 + 2
            ExprValue tmp1 = TJC.exprGetValue(interp, 1, null);
            ExprValue tmp2 = TJC.exprGetValue(interp, 2, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp1, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
            // End Binary operator: +
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MULT, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: *
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.8 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {(1 + 2) * (3 + 4)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {(1 + 2) * (3 + 4)}
            // Binary operator: () * ()
            // Binary operator: 1 + 2
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
            ExprValue tmp1 = TJC.exprGetValue(interp, 2, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: +
            // Binary operator: 3 + 4
            ExprValue tmp2 = TJC.exprGetValue(interp, 3, null);
            ExprValue tmp3 = TJC.exprGetValue(interp, 4, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp2, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: +
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MULT, tmp0, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
            // End Binary operator: *
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.9 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {(!1) + (~1)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {(!1) + (~1)}
            // Binary operator: () + ()
            // Unary operator: ! 1
            ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp0);
            // End Unary operator: !
            // Unary operator: ~ 1
            ExprValue tmp1 = TJC.exprGetValue(interp, ~1, null);
            // End Unary operator: ~
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.10 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {$a && $b}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$a && $b}
            // Binary operator: $a && $b
            TclObject tmp0 = interp.getVar("a", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            if (tmp1.getBooleanValue(interp)) {
            TclObject tmp2 = interp.getVar("b", null, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            tmp1.setIntValue(tmp3.getBooleanValue(interp));
            TJC.exprReleaseValue(interp, tmp3);
            } else {
            tmp1.setIntValue(0);
            } // End if: $a
            // End Binary operator: &&
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.11 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {$a || $b}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$a || $b}
            // Binary operator: $a || $b
            TclObject tmp0 = interp.getVar("a", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            if (!tmp1.getBooleanValue(interp)) {
            TclObject tmp2 = interp.getVar("b", null, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            tmp1.setIntValue(tmp3.getBooleanValue(interp));
            TJC.exprReleaseValue(interp, tmp3);
            } else {
            tmp1.setIntValue(1);
            } // End if: !$a
            // End Binary operator: ||
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.12 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {$a ? $b : $c}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$a ? $b : $c}
            // Ternary operator: $a ? $b : $c
            TclObject tmp0 = interp.getVar("a", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            if (tmp1.getBooleanValue(interp)) {
            TclObject tmp2 = interp.getVar("b", null, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp1);
            tmp1 = tmp3;
            } else {
            TclObject tmp4 = interp.getVar("c", null, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TJC.exprReleaseValue(interp, tmp1);
            tmp1 = tmp5;
            }
            // End Ternary operator: ?
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}


tcltest::test compileproc2-9.13 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {pow(2,2)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {pow(2,2)}
            // Math function: pow 2 2
            ExprValue tmp0 = TJC.exprGetValue(interp, 2, null);
            ExprValue tmp1 = TJC.exprGetValue(interp, 2, null);
            ExprValue[] tmp2 = new ExprValue[2];
            tmp2[0] = tmp0;
            tmp2[1] = tmp1;
            ExprValue tmp3 = TJC.exprGetValue(interp);
            TJC.exprMathFunction(interp, "pow", tmp2, tmp3);
            TJC.exprReleaseValue(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp0);
            // End Math function: pow
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.14 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {[cmd] == []}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {[cmd] == []}
            // Binary operator: [...] == []
            { // Invoke: cmd
                TclObject[] objv0 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: cmd
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 1);
                }
            } // End Invoke: cmd
            TclObject tmp2 = interp.getResult();
            ExprValue tmp3 = TJC.exprGetValue(interp);
            TJC.exprEqualsEmptyString(tmp3, tmp2, false);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.15 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {"${s}[cmd]" == "\n"}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set test_compileproc_2_expr_no_string_compare_optimizations 1
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr ...
            // Binary operator: "..." == "\n"
            TclObject tmp0;
            StringBuffer sbtmp1 = new StringBuffer(64);
            tmp0 = interp.getVar("s", null, 0);
            sbtmp1.append(tmp0.toString());
            { // Invoke: cmd
                TclObject[] objv2 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp3;
                    // Arg 0 constant: cmd
                    tmp3 = const0;
                    tmp3.preserve();
                    objv2[0] = tmp3;
                    TJC.invoke(interp, null, objv2, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv2, 1);
                }
            } // End Invoke: cmd
            tmp0 = interp.getResult();
            sbtmp1.append(tmp0.toString());
            tmp0 = TclString.newInstance(sbtmp1);
            ExprValue tmp4 = TJC.exprGetValue(interp, tmp0);
            ExprValue tmp5 = TJC.exprGetValue(interp, "\n");
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp4, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.16 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {""}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {""}
            ExprValue tmp0 = TJC.exprGetValue(interp, "");
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.17 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {"\t2.0"}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr ...
            ExprValue tmp0 = TJC.exprGetValue(interp, 2.0, "\t2.0");
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.18 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    set s {\t1.0}
    expr {$s eq {\t1.0}}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set test_compileproc_2_expr_no_string_compare_optimizations 1
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set s ...
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: s
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: ...
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        { // Invoke: expr ...
            // Binary operator: $s eq "\\t1.0"
            TclObject tmp2 = interp.getVar("s", null, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            ExprValue tmp4 = TJC.exprGetValue(interp, "\\t1.0");
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STREQ, tmp3, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("s");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("\\t1.0");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.19 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {-1}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {-1}
            // Unary operator: - 1
            ExprValue tmp0 = TJC.exprGetValue(interp, -1, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.20 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {-0x80000000}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {-0x80000000}
            // Unary operator: - "0x80000000"
            ExprValue tmp0 = TJC.exprGetValue(interp, -2147483648, "-0x80000000");
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.21 {compile proc into Java source, +inline-containers} {
    # inline expr container command
    set script {
proc p {} {
    expr {sqrt(1.0) + (1 ? 2 : !3)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr ...
            // Binary operator: math() + (?:)
            // Math function: sqrt 1.0
            ExprValue tmp0 = TJC.exprGetValue(interp, 1.0, null);
            ExprValue[] tmp1 = new ExprValue[1];
            tmp1[0] = tmp0;
            ExprValue tmp2 = TJC.exprGetValue(interp);
            TJC.exprMathFunction(interp, "sqrt", tmp1, tmp2);
            TJC.exprReleaseValue(interp, tmp0);
            // End Math function: sqrt
            // Ternary operator: 1 ? 2 : ()
            ExprValue tmp3 = TJC.exprGetValue(interp, 1, null);
            if (tmp3.getBooleanValue(interp)) {
            ExprValue tmp4 = TJC.exprGetValue(interp, 2, null);
            TJC.exprReleaseValue(interp, tmp3);
            tmp3 = tmp4;
            } else {
            // Unary operator: ! 3
            ExprValue tmp5 = TJC.exprGetValue(interp, 3, null);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp5);
            // End Unary operator: !
            TJC.exprReleaseValue(interp, tmp3);
            tmp3 = tmp5;
            }
            // End Ternary operator: ?
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp2, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.22 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for an
    # optimization when comparing a Tcl object to the constant
    # empty string.
    set script {
proc p {} {
    expr {$obj == ""}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$obj == ""}
            // Binary operator: $obj == ""
            TclObject tmp0 = interp.getVar("obj", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp);
            TJC.exprEqualsEmptyString(tmp1, tmp0, false);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.23 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for an
    # optimization when comparing a Tcl object to the constant
    # empty string.
    set script {
proc p {} {
    expr {$obj != ""}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$obj != ""}
            // Binary operator: $obj != ""
            TclObject tmp0 = interp.getVar("obj", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp);
            TJC.exprEqualsEmptyString(tmp1, tmp0, true);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.24 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for an
    # optimization when comparing a Tcl object to the constant
    # empty string.
    set script {
proc p {} {
    expr {[cmd] eq ""}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {[cmd] eq ""}
            // Binary operator: [...] eq ""
            { // Invoke: cmd
                TclObject[] objv0 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: cmd
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 1);
                }
            } // End Invoke: cmd
            TclObject tmp2 = interp.getResult();
            ExprValue tmp3 = TJC.exprGetValue(interp);
            TJC.exprEqualsEmptyString(tmp3, tmp2, false);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.25 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for an
    # optimization when comparing a Tcl object to the constant
    # empty string.
    set script {
proc p {} {
    expr {[cmd] ne {}}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {[cmd] ne {}}
            // Binary operator: [...] ne ""
            { // Invoke: cmd
                TclObject[] objv0 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: cmd
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 1);
                }
            } // End Invoke: cmd
            TclObject tmp2 = interp.getResult();
            ExprValue tmp3 = TJC.exprGetValue(interp);
            TJC.exprEqualsEmptyString(tmp3, tmp2, true);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.26 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for an
    # optimization when comparing a Tcl object to the constant
    # non-empty string.
    set script {
proc p {} {
    expr {$obj == "foo"}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$obj == "foo"}
            // Binary operator: $obj == "foo"
            TclObject tmp0 = interp.getVar("obj", null, 0);
            boolean tmp1 = tmp0.toString().equals("foo");
            ExprValue tmp2 = TJC.exprGetValue(interp, tmp1);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.27 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for an
    # optimization when comparing a Tcl object to the constant
    # non-empty string.
    set script {
proc p {} {
    expr {$obj != "foo"}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {$obj != "foo"}
            // Binary operator: $obj != "foo"
            TclObject tmp0 = interp.getVar("obj", null, 0);
            boolean tmp1 = ! tmp0.toString().equals("foo");
            ExprValue tmp2 = TJC.exprGetValue(interp, tmp1);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.28 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this is like
    # test compileproc2-9.18 except that it makes
    # use of the string compare optimization.
    set script {
proc p {} {
    set s {\t1.0}
    expr {$s eq {\t1.0}}
}
}
    set plist [compileproc_script_to_proc_list $script]
    #set test_compileproc_2_expr_no_string_compare_optimizations 1
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set s ...
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: s
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: ...
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        { // Invoke: expr ...
            // Binary operator: $s eq "\\t1.0"
            TclObject tmp2 = interp.getVar("s", null, 0);
            boolean tmp3 = tmp2.toString().equals("\\t1.0");
            ExprValue tmp4 = TJC.exprGetValue(interp, tmp3);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("s");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("\\t1.0");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.29 {compile proc into Java source, +inline-containers} {
    # inline expr container command, the int() math function
    # should always be inlined.
    set script {
proc p {} {
    expr {int($s)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {int($s)}
            // Math function: int $s
            TclObject tmp0 = interp.getVar("s", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TJC.exprIntMathFunction(interp, tmp1);
            // End Math function: int
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.30 {compile proc into Java source, +inline-containers} {
    # inline expr container command, the double() math function
    # should always be inlined.
    set script {
proc p {} {
    expr {double($s)}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {double($s)}
            // Math function: double $s
            TclObject tmp0 = interp.getVar("s", null, 0);
            ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
            TJC.exprDoubleMathFunction(interp, tmp1);
            // End Math function: double
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.31 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this checks for boolean tokens.
    set script {
proc p {} {
    expr {tru == true}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {tru == true}
            // Binary operator: "tru" == "true"
            ExprValue tmp0 = TJC.exprGetValue(interp, "tru");
            ExprValue tmp1 = TJC.exprGetValue(interp, "true");
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.32 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this checks for boolean tokens.
    set script {
proc p {} {
    expr {f == t}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {f == t}
            // Binary operator: "f" == "t"
            ExprValue tmp0 = TJC.exprGetValue(interp, "f");
            ExprValue tmp1 = TJC.exprGetValue(interp, "t");
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.33 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for the
    # output format of a double number.
    set script {
proc p {} {
    expr {"7.91e16" == 7.91e+16}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr ...
            // Binary operator: 7.91e16 == 7.91e16
            ExprValue tmp0 = TJC.exprGetValue(interp, 7.91e16, "7.91e16");
            ExprValue tmp1 = TJC.exprGetValue(interp, 7.91e16, "7.91e+16");
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.34 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks for the
    # output format of a double number.
    set script {
proc p {} {
    expr {7.91e+016 == 7.91e-16}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr ...
            // Binary operator: 7.91e16 == 7.91e-16
            ExprValue tmp0 = TJC.exprGetValue(interp, 7.91e16, null);
            ExprValue tmp1 = TJC.exprGetValue(interp, 7.91e-16, "7.91e-16");
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.35 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks that
    # the rand() function with no arguments is parsed properly.
    set script {
proc p {} {
    expr {rand()}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {rand()}
            // Math function: rand
            ExprValue tmp0 = TJC.exprGetValue(interp);
            TJC.exprMathFunction(interp, "rand", null, tmp0);
            // End Math function: rand
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.36 {compile proc into Java source, +inline-containers} {
    # inline expr container command, this test checks that
    # the rand() function with no arguments is parsed properly.
    set script {
proc p {} {
    expr {rand() * 1}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {rand() * 1}
            // Binary operator: math() * 1
            // Math function: rand
            ExprValue tmp0 = TJC.exprGetValue(interp);
            TJC.exprMathFunction(interp, "rand", null, tmp0);
            // End Math function: rand
            ExprValue tmp1 = TJC.exprGetValue(interp, 1, null);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MULT, tmp0, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
            // End Binary operator: *
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.37 {compile proc into Java source, +inline-containers} {
    # expression contains a single unary operator

    set script {
proc p {} {
    expr {-1}
    expr {+1}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {-1}
            // Unary operator: - 1
            ExprValue tmp0 = TJC.exprGetValue(interp, -1, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {+1}
            // Unary operator: + 1
            ExprValue tmp1 = TJC.exprGetValue(interp, 1, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.38 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    # Unary operator applied to int literal
    expr {-1}
    expr {- 1}
    # Unary operator applied two times to int literal
    expr {- -1}
    # Unary operator applied to int literal
    expr {+1}
    expr {+ 1}
    # Unary operator applied two times to int literal
    expr {+ +1}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {-1}
            // Unary operator: - 1
            ExprValue tmp0 = TJC.exprGetValue(interp, -1, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {- 1}
            // Unary operator: - 1
            ExprValue tmp1 = TJC.exprGetValue(interp, -1, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {- -1}
            // Unary operator: - ()
            // Unary operator: - 1
            ExprValue tmp2 = TJC.exprGetValue(interp, -1, null);
            // End Unary operator: -
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_MINUS, tmp2);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        { // Invoke: expr {+1}
            // Unary operator: + 1
            ExprValue tmp3 = TJC.exprGetValue(interp, 1, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        { // Invoke: expr {+ 1}
            // Unary operator: + 1
            ExprValue tmp4 = TJC.exprGetValue(interp, 1, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
        } // End Invoke: expr
        { // Invoke: expr {+ +1}
            // Unary operator: + ()
            // Unary operator: + 1
            ExprValue tmp5 = TJC.exprGetValue(interp, 1, null);
            // End Unary operator: +
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_PLUS, tmp5);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.39 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    # Unary operator applied to hex int literal
    expr {+0xFF}
    expr {-0xFF}
    expr {+ 0xFF}
    expr {- 0xFF}
    expr {+ "0XFF"}
    expr {- "0XFF"}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {+0xFF}
            // Unary operator: + 255
            ExprValue tmp0 = TJC.exprGetValue(interp, 255, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {-0xFF}
            // Unary operator: - 255
            ExprValue tmp1 = TJC.exprGetValue(interp, -255, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {+ 0xFF}
            // Unary operator: + 255
            ExprValue tmp2 = TJC.exprGetValue(interp, 255, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        { // Invoke: expr {- 0xFF}
            // Unary operator: - 255
            ExprValue tmp3 = TJC.exprGetValue(interp, -255, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        { // Invoke: expr {+ "0XFF"}
            // Unary operator: + 255
            ExprValue tmp4 = TJC.exprGetValue(interp, 255, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp4);
            TJC.exprReleaseValue(interp, tmp4);
        } // End Invoke: expr
        { // Invoke: expr {- "0XFF"}
            // Unary operator: - 255
            ExprValue tmp5 = TJC.exprGetValue(interp, -255, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.40 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    # Unary operator applied to double literal
    expr {+ 1.0}
    expr {- 1.0}
    # Unary operator applied to double literal,
    # the string rep is discarded at compile time.
    expr {+ 1e0}
    expr {- 1e0}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {+ 1.0}
            // Unary operator: + 1.0
            ExprValue tmp0 = TJC.exprGetValue(interp, 1.0, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {- 1.0}
            // Unary operator: - 1.0
            ExprValue tmp1 = TJC.exprGetValue(interp, -1.0, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        { // Invoke: expr {+ 1e0}
            // Unary operator: + 1.0
            ExprValue tmp2 = TJC.exprGetValue(interp, 1.0, null);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp2);
            TJC.exprReleaseValue(interp, tmp2);
        } // End Invoke: expr
        { // Invoke: expr {- 1e0}
            // Unary operator: - 1.0
            ExprValue tmp3 = TJC.exprGetValue(interp, -1.0, null);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.41 {compile proc into Java source, +inline-containers} {
    set script {
proc p {} {
    # Unary operator applied to int literal becomes
    # a compile time constant integer value.
    expr {~ 0}
    # Unary operator not applied at compile time since
    # bitwise not operator works only with integers.
    expr {~ 0.0}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: expr {~ 0}
            // Unary operator: ~ 0
            ExprValue tmp0 = TJC.exprGetValue(interp, ~0, null);
            // End Unary operator: ~
            TJC.exprSetResult(interp, tmp0);
            TJC.exprReleaseValue(interp, tmp0);
        } // End Invoke: expr
        { // Invoke: expr {~ 0.0}
            // Unary operator: ~ 0.0
            ExprValue tmp1 = TJC.exprGetValue(interp, 0.0, null);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_BIT_NOT, tmp1);
            // End Unary operator: ~
            TJC.exprSetResult(interp, tmp1);
            TJC.exprReleaseValue(interp, tmp1);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-9.42 {compile proc into Java source, +inline-containers} {
    # This test contains an invocation for each unary operator
    # applied to a variable.
    set script {
proc p {} {
    set v 1
    expr {+$v}
    expr {-$v}
    expr {!$v}
    expr {~$v}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set v 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: v
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        { // Invoke: expr {+$v}
            // Unary operator: + $v
            TclObject tmp2 = interp.getVar("v", null, 0);
            ExprValue tmp3 = TJC.exprGetValue(interp, tmp2);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_PLUS, tmp3);
            // End Unary operator: +
            TJC.exprSetResult(interp, tmp3);
            TJC.exprReleaseValue(interp, tmp3);
        } // End Invoke: expr
        { // Invoke: expr {-$v}
            // Unary operator: - $v
            TclObject tmp4 = interp.getVar("v", null, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_MINUS, tmp5);
            // End Unary operator: -
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        { // Invoke: expr {!$v}
            // Unary operator: ! $v
            TclObject tmp6 = interp.getVar("v", null, 0);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_NOT, tmp7);
            // End Unary operator: !
            TJC.exprSetResult(interp, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
        } // End Invoke: expr
        { // Invoke: expr {~$v}
            // Unary operator: ~ $v
            TclObject tmp8 = interp.getVar("v", null, 0);
            ExprValue tmp9 = TJC.exprGetValue(interp, tmp8);
            TJC.exprUnaryOperator(interp, TJC.EXPR_OP_UNARY_BIT_NOT, tmp9);
            // End Unary operator: ~
            TJC.exprSetResult(interp, tmp9);
            TJC.exprReleaseValue(interp, tmp9);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("v");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(1);
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-9.43 {compile proc into Java source, +inline-containers} {
    # This test contains an invocation for each binary operator
    set script {
proc p {} {
    set v1 1
    set v2 2
    expr {$v1 * $v2}
    expr {$v1 / $v2}
    expr {$v1 % $v2}
    expr {$v1 + $v2}
    expr {$v1 - $v2}
    expr {$v1 << $v2}
    expr {$v1 >> $v2}
    expr {$v1 < $v2}
    expr {$v1 > $v2}
    expr {$v1 <= $v2}
    expr {$v1 >= $v2}
    expr {$v1 == $v2}
    expr {$v1 != $v2}
    expr {$v1 eq $v2}
    expr {$v1 ne $v2}
    expr {$v1 & $v2}
    expr {$v1 ^ $v2}
    expr {$v1 | $v2}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set v1 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: v1
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        { // Invoke: set v2 2
            TclObject[] objv2 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp3;
                // Arg 0 constant: set
                tmp3 = const0;
                tmp3.preserve();
                objv2[0] = tmp3;
                // Arg 1 constant: v2
                tmp3 = const3;
                tmp3.preserve();
                objv2[1] = tmp3;
                // Arg 2 constant: 2
                tmp3 = const4;
                tmp3.preserve();
                objv2[2] = tmp3;
                TJC.invoke(interp, null, objv2, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 3);
            }
        } // End Invoke: set
        { // Invoke: expr {$v1 * $v2}
            // Binary operator: $v1 * $v2
            TclObject tmp4 = interp.getVar("v1", null, 0);
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            TclObject tmp6 = interp.getVar("v2", null, 0);
            ExprValue tmp7 = TJC.exprGetValue(interp, tmp6);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MULT, tmp5, tmp7);
            TJC.exprReleaseValue(interp, tmp7);
            // End Binary operator: *
            TJC.exprSetResult(interp, tmp5);
            TJC.exprReleaseValue(interp, tmp5);
        } // End Invoke: expr
        { // Invoke: expr {$v1 / $v2}
            // Binary operator: $v1 / $v2
            TclObject tmp8 = interp.getVar("v1", null, 0);
            ExprValue tmp9 = TJC.exprGetValue(interp, tmp8);
            TclObject tmp10 = interp.getVar("v2", null, 0);
            ExprValue tmp11 = TJC.exprGetValue(interp, tmp10);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_DIVIDE, tmp9, tmp11);
            TJC.exprReleaseValue(interp, tmp11);
            // End Binary operator: /
            TJC.exprSetResult(interp, tmp9);
            TJC.exprReleaseValue(interp, tmp9);
        } // End Invoke: expr
        { // Invoke: expr {$v1 % $v2}
            // Binary operator: $v1 % $v2
            TclObject tmp12 = interp.getVar("v1", null, 0);
            ExprValue tmp13 = TJC.exprGetValue(interp, tmp12);
            TclObject tmp14 = interp.getVar("v2", null, 0);
            ExprValue tmp15 = TJC.exprGetValue(interp, tmp14);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MOD, tmp13, tmp15);
            TJC.exprReleaseValue(interp, tmp15);
            // End Binary operator: %
            TJC.exprSetResult(interp, tmp13);
            TJC.exprReleaseValue(interp, tmp13);
        } // End Invoke: expr
        { // Invoke: expr {$v1 + $v2}
            // Binary operator: $v1 + $v2
            TclObject tmp16 = interp.getVar("v1", null, 0);
            ExprValue tmp17 = TJC.exprGetValue(interp, tmp16);
            TclObject tmp18 = interp.getVar("v2", null, 0);
            ExprValue tmp19 = TJC.exprGetValue(interp, tmp18);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_PLUS, tmp17, tmp19);
            TJC.exprReleaseValue(interp, tmp19);
            // End Binary operator: +
            TJC.exprSetResult(interp, tmp17);
            TJC.exprReleaseValue(interp, tmp17);
        } // End Invoke: expr
        { // Invoke: expr {$v1 - $v2}
            // Binary operator: $v1 - $v2
            TclObject tmp20 = interp.getVar("v1", null, 0);
            ExprValue tmp21 = TJC.exprGetValue(interp, tmp20);
            TclObject tmp22 = interp.getVar("v2", null, 0);
            ExprValue tmp23 = TJC.exprGetValue(interp, tmp22);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_MINUS, tmp21, tmp23);
            TJC.exprReleaseValue(interp, tmp23);
            // End Binary operator: -
            TJC.exprSetResult(interp, tmp21);
            TJC.exprReleaseValue(interp, tmp21);
        } // End Invoke: expr
        { // Invoke: expr {$v1 << $v2}
            // Binary operator: $v1 << $v2
            TclObject tmp24 = interp.getVar("v1", null, 0);
            ExprValue tmp25 = TJC.exprGetValue(interp, tmp24);
            TclObject tmp26 = interp.getVar("v2", null, 0);
            ExprValue tmp27 = TJC.exprGetValue(interp, tmp26);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_LEFT_SHIFT, tmp25, tmp27);
            TJC.exprReleaseValue(interp, tmp27);
            // End Binary operator: <<
            TJC.exprSetResult(interp, tmp25);
            TJC.exprReleaseValue(interp, tmp25);
        } // End Invoke: expr
        { // Invoke: expr {$v1 >> $v2}
            // Binary operator: $v1 >> $v2
            TclObject tmp28 = interp.getVar("v1", null, 0);
            ExprValue tmp29 = TJC.exprGetValue(interp, tmp28);
            TclObject tmp30 = interp.getVar("v2", null, 0);
            ExprValue tmp31 = TJC.exprGetValue(interp, tmp30);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_RIGHT_SHIFT, tmp29, tmp31);
            TJC.exprReleaseValue(interp, tmp31);
            // End Binary operator: >>
            TJC.exprSetResult(interp, tmp29);
            TJC.exprReleaseValue(interp, tmp29);
        } // End Invoke: expr
        { // Invoke: expr {$v1 < $v2}
            // Binary operator: $v1 < $v2
            TclObject tmp32 = interp.getVar("v1", null, 0);
            ExprValue tmp33 = TJC.exprGetValue(interp, tmp32);
            TclObject tmp34 = interp.getVar("v2", null, 0);
            ExprValue tmp35 = TJC.exprGetValue(interp, tmp34);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_LESS, tmp33, tmp35);
            TJC.exprReleaseValue(interp, tmp35);
            // End Binary operator: <
            TJC.exprSetResult(interp, tmp33);
            TJC.exprReleaseValue(interp, tmp33);
        } // End Invoke: expr
        { // Invoke: expr {$v1 > $v2}
            // Binary operator: $v1 > $v2
            TclObject tmp36 = interp.getVar("v1", null, 0);
            ExprValue tmp37 = TJC.exprGetValue(interp, tmp36);
            TclObject tmp38 = interp.getVar("v2", null, 0);
            ExprValue tmp39 = TJC.exprGetValue(interp, tmp38);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_GREATER, tmp37, tmp39);
            TJC.exprReleaseValue(interp, tmp39);
            // End Binary operator: >
            TJC.exprSetResult(interp, tmp37);
            TJC.exprReleaseValue(interp, tmp37);
        } // End Invoke: expr
        { // Invoke: expr {$v1 <= $v2}
            // Binary operator: $v1 <= $v2
            TclObject tmp40 = interp.getVar("v1", null, 0);
            ExprValue tmp41 = TJC.exprGetValue(interp, tmp40);
            TclObject tmp42 = interp.getVar("v2", null, 0);
            ExprValue tmp43 = TJC.exprGetValue(interp, tmp42);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_LEQ, tmp41, tmp43);
            TJC.exprReleaseValue(interp, tmp43);
            // End Binary operator: <=
            TJC.exprSetResult(interp, tmp41);
            TJC.exprReleaseValue(interp, tmp41);
        } // End Invoke: expr
        { // Invoke: expr {$v1 >= $v2}
            // Binary operator: $v1 >= $v2
            TclObject tmp44 = interp.getVar("v1", null, 0);
            ExprValue tmp45 = TJC.exprGetValue(interp, tmp44);
            TclObject tmp46 = interp.getVar("v2", null, 0);
            ExprValue tmp47 = TJC.exprGetValue(interp, tmp46);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_GEQ, tmp45, tmp47);
            TJC.exprReleaseValue(interp, tmp47);
            // End Binary operator: >=
            TJC.exprSetResult(interp, tmp45);
            TJC.exprReleaseValue(interp, tmp45);
        } // End Invoke: expr
        { // Invoke: expr {$v1 == $v2}
            // Binary operator: $v1 == $v2
            TclObject tmp48 = interp.getVar("v1", null, 0);
            ExprValue tmp49 = TJC.exprGetValue(interp, tmp48);
            TclObject tmp50 = interp.getVar("v2", null, 0);
            ExprValue tmp51 = TJC.exprGetValue(interp, tmp50);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_EQUAL, tmp49, tmp51);
            TJC.exprReleaseValue(interp, tmp51);
            // End Binary operator: ==
            TJC.exprSetResult(interp, tmp49);
            TJC.exprReleaseValue(interp, tmp49);
        } // End Invoke: expr
        { // Invoke: expr {$v1 != $v2}
            // Binary operator: $v1 != $v2
            TclObject tmp52 = interp.getVar("v1", null, 0);
            ExprValue tmp53 = TJC.exprGetValue(interp, tmp52);
            TclObject tmp54 = interp.getVar("v2", null, 0);
            ExprValue tmp55 = TJC.exprGetValue(interp, tmp54);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_NEQ, tmp53, tmp55);
            TJC.exprReleaseValue(interp, tmp55);
            // End Binary operator: !=
            TJC.exprSetResult(interp, tmp53);
            TJC.exprReleaseValue(interp, tmp53);
        } // End Invoke: expr
        { // Invoke: expr {$v1 eq $v2}
            // Binary operator: $v1 eq $v2
            TclObject tmp56 = interp.getVar("v1", null, 0);
            ExprValue tmp57 = TJC.exprGetValue(interp, tmp56);
            TclObject tmp58 = interp.getVar("v2", null, 0);
            ExprValue tmp59 = TJC.exprGetValue(interp, tmp58);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STREQ, tmp57, tmp59);
            TJC.exprReleaseValue(interp, tmp59);
            // End Binary operator: eq
            TJC.exprSetResult(interp, tmp57);
            TJC.exprReleaseValue(interp, tmp57);
        } // End Invoke: expr
        { // Invoke: expr {$v1 ne $v2}
            // Binary operator: $v1 ne $v2
            TclObject tmp60 = interp.getVar("v1", null, 0);
            ExprValue tmp61 = TJC.exprGetValue(interp, tmp60);
            TclObject tmp62 = interp.getVar("v2", null, 0);
            ExprValue tmp63 = TJC.exprGetValue(interp, tmp62);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_STRNEQ, tmp61, tmp63);
            TJC.exprReleaseValue(interp, tmp63);
            // End Binary operator: ne
            TJC.exprSetResult(interp, tmp61);
            TJC.exprReleaseValue(interp, tmp61);
        } // End Invoke: expr
        { // Invoke: expr {$v1 & $v2}
            // Binary operator: $v1 & $v2
            TclObject tmp64 = interp.getVar("v1", null, 0);
            ExprValue tmp65 = TJC.exprGetValue(interp, tmp64);
            TclObject tmp66 = interp.getVar("v2", null, 0);
            ExprValue tmp67 = TJC.exprGetValue(interp, tmp66);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_BIT_AND, tmp65, tmp67);
            TJC.exprReleaseValue(interp, tmp67);
            // End Binary operator: &
            TJC.exprSetResult(interp, tmp65);
            TJC.exprReleaseValue(interp, tmp65);
        } // End Invoke: expr
        { // Invoke: expr {$v1 ^ $v2}
            // Binary operator: $v1 ^ $v2
            TclObject tmp68 = interp.getVar("v1", null, 0);
            ExprValue tmp69 = TJC.exprGetValue(interp, tmp68);
            TclObject tmp70 = interp.getVar("v2", null, 0);
            ExprValue tmp71 = TJC.exprGetValue(interp, tmp70);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_BIT_XOR, tmp69, tmp71);
            TJC.exprReleaseValue(interp, tmp71);
            // End Binary operator: ^
            TJC.exprSetResult(interp, tmp69);
            TJC.exprReleaseValue(interp, tmp69);
        } // End Invoke: expr
        { // Invoke: expr {$v1 | $v2}
            // Binary operator: $v1 | $v2
            TclObject tmp72 = interp.getVar("v1", null, 0);
            ExprValue tmp73 = TJC.exprGetValue(interp, tmp72);
            TclObject tmp74 = interp.getVar("v2", null, 0);
            ExprValue tmp75 = TJC.exprGetValue(interp, tmp74);
            TJC.exprBinaryOperator(interp, TJC.EXPR_OP_BIT_OR, tmp73, tmp75);
            TJC.exprReleaseValue(interp, tmp75);
            // End Binary operator: |
            TJC.exprSetResult(interp, tmp73);
            TJC.exprReleaseValue(interp, tmp73);
        } // End Invoke: expr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;
    TclObject const3;
    TclObject const4;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("v1");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(1);
        const2.preserve(); const2.preserve();
        const3 = TclString.newInstance("v2");
        const3.preserve(); const3.preserve();
        const4 = TclInteger.newInstance(2);
        const4.preserve(); const4.preserve();
    }
} // end class Test1
}}


tcltest::test compileproc2-10.0 {compile proc into Java source, +inline-containers} {
    # inline if container command and boolean expr expression.
    set script {
proc p {} {
    if {1.0 || 0} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {1.0 || 0} {}
            // Binary operator: 1.0 || 0
            ExprValue tmp0 = TJC.exprGetValue(interp, 1.0, null);
            if (!tmp0.getBooleanValue(interp)) {
            ExprValue tmp1 = TJC.exprGetValue(interp, 0, null);
            tmp0.setIntValue(tmp1.getBooleanValue(interp));
            TJC.exprReleaseValue(interp, tmp1);
            } else {
            tmp0.setIntValue(1);
            } // End if: !1.0
            // End Binary operator: ||
            boolean tmp2 = tmp0.getBooleanValue(interp);
            TJC.exprReleaseValue(interp, tmp0);
            if ( tmp2 ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-10.1 {compile proc into Java source, +inline-containers} {
    # inline if container command and boolean expr expression.
    set script {
proc p {} {
    if {0} {} elseif {1||1} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {0} {} elseif {1||1} {}
            if ( false ) {
                interp.resetResult();
            } else {
                // Binary operator: 1 || 1
                ExprValue tmp0 = TJC.exprGetValue(interp, 1, null);
                if (!tmp0.getBooleanValue(interp)) {
                ExprValue tmp1 = TJC.exprGetValue(interp, 1, null);
                tmp0.setIntValue(tmp1.getBooleanValue(interp));
                TJC.exprReleaseValue(interp, tmp1);
                } else {
                tmp0.setIntValue(1);
                } // End if: !1
                // End Binary operator: ||
                boolean tmp2 = tmp0.getBooleanValue(interp);
                TJC.exprReleaseValue(interp, tmp0);
                if ( tmp2 ) {
                    interp.resetResult();
                } else {
                    interp.resetResult();
                }
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-10.2 {compile proc into Java source, +inline-containers} {
    # inline if container command and boolean expr expression.
    set script {
proc p {} {
    if {$b1} {} elseif {$b2} {} else {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {$b1} {} elseif {$b2} {} else {}
            TclObject tmp0 = interp.getVar("b1", null, 0);
            boolean tmp1 = TJC.getBoolean(interp, tmp0);
            if ( tmp1 ) {
                interp.resetResult();
            } else {
                TclObject tmp2 = interp.getVar("b2", null, 0);
                boolean tmp3 = TJC.getBoolean(interp, tmp2);
                if ( tmp3 ) {
                    interp.resetResult();
                } else {
                    interp.resetResult();
                }
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-10.3 {compile proc into Java source, +inline-containers} {
    # inline if container command and boolean expr expression.
    set script {
proc p {} {
    if {$b1} {
        cmd
    } elseif {$b2} {
        cmd
    } elseif {$b3} {
        cmd
    } else {
        cmd
    }
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {$b1} ... elseif {$b2} ... elseif {$b3} ... else ...
            TclObject tmp0 = interp.getVar("b1", null, 0);
            boolean tmp1 = TJC.getBoolean(interp, tmp0);
            if ( tmp1 ) {
                { // Invoke: cmd
                    TclObject[] objv2 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: cmd
                        tmp3 = const0;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 1);
                    }
                } // End Invoke: cmd
            } else {
                TclObject tmp4 = interp.getVar("b2", null, 0);
                boolean tmp5 = TJC.getBoolean(interp, tmp4);
                if ( tmp5 ) {
                    { // Invoke: cmd
                        TclObject[] objv6 = TJC.grabObjv(interp, 1);
                        try {
                            TclObject tmp7;
                            // Arg 0 constant: cmd
                            tmp7 = const0;
                            tmp7.preserve();
                            objv6[0] = tmp7;
                            TJC.invoke(interp, null, objv6, 0);
                        } finally {
                            TJC.releaseObjvElems(interp, objv6, 1);
                        }
                    } // End Invoke: cmd
                } else {
                    TclObject tmp8 = interp.getVar("b3", null, 0);
                    boolean tmp9 = TJC.getBoolean(interp, tmp8);
                    if ( tmp9 ) {
                        { // Invoke: cmd
                            TclObject[] objv10 = TJC.grabObjv(interp, 1);
                            try {
                                TclObject tmp11;
                                // Arg 0 constant: cmd
                                tmp11 = const0;
                                tmp11.preserve();
                                objv10[0] = tmp11;
                                TJC.invoke(interp, null, objv10, 0);
                            } finally {
                                TJC.releaseObjvElems(interp, objv10, 1);
                            }
                        } // End Invoke: cmd
                    } else {
                        { // Invoke: cmd
                            TclObject[] objv12 = TJC.grabObjv(interp, 1);
                            try {
                                TclObject tmp13;
                                // Arg 0 constant: cmd
                                tmp13 = const0;
                                tmp13.preserve();
                                objv12[0] = tmp13;
                                TJC.invoke(interp, null, objv12, 0);
                            } finally {
                                TJC.releaseObjvElems(interp, objv12, 1);
                            }
                        } // End Invoke: cmd
                    }
                }
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc2-10.4 {compile proc into Java source, +inline-containers} {
    # inline while container command and boolean expr expression.
    set script {
proc p {} {
    while {($n / 100) != 0} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: while {($n / 100) != 0} {}
            for ( ; true ; ) {
                // Binary operator: () != 0
                // Binary operator: $n / 100
                TclObject tmp0 = interp.getVar("n", null, 0);
                ExprValue tmp1 = TJC.exprGetValue(interp, tmp0);
                ExprValue tmp2 = TJC.exprGetValue(interp, 100, null);
                TJC.exprBinaryOperator(interp, TJC.EXPR_OP_DIVIDE, tmp1, tmp2);
                TJC.exprReleaseValue(interp, tmp2);
                // End Binary operator: /
                ExprValue tmp3 = TJC.exprGetValue(interp, 0, null);
                TJC.exprBinaryOperator(interp, TJC.EXPR_OP_NEQ, tmp1, tmp3);
                TJC.exprReleaseValue(interp, tmp3);
                // End Binary operator: !=
                boolean tmp4 = tmp1.getBooleanValue(interp);
                TJC.exprReleaseValue(interp, tmp1);
                if ( ! tmp4 ) { break; }
            }
            interp.resetResult();
        } // End Invoke: while
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc2-10.5 {compile proc into Java source, +inline-containers} {
    # inline if container command with 2 nested commands in an expr block
    set script {
proc p {} {
    if {[set x 0 ; incr x]} {}
}
}
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_2_set_flags]
    # Print generated buffer even if compile fails
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: if {[set x 0 ; incr x]} {}
            { // Invoke: set x 0
                TclObject[] objv0 = TJC.grabObjv(interp, 3);
                try {
                    TclObject tmp1;
                    // Arg 0 constant: set
                    tmp1 = const0;
                    tmp1.preserve();
                    objv0[0] = tmp1;
                    // Arg 1 constant: x
                    tmp1 = const1;
                    tmp1.preserve();
                    objv0[1] = tmp1;
                    // Arg 2 constant: 0
                    tmp1 = const2;
                    tmp1.preserve();
                    objv0[2] = tmp1;
                    TJC.invoke(interp, null, objv0, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv0, 3);
                }
            } // End Invoke: set
            { // Invoke: incr x
                TclObject[] objv2 = TJC.grabObjv(interp, 2);
                try {
                    TclObject tmp3;
                    // Arg 0 constant: incr
                    tmp3 = const3;
                    tmp3.preserve();
                    objv2[0] = tmp3;
                    // Arg 1 constant: x
                    tmp3 = const1;
                    tmp3.preserve();
                    objv2[1] = tmp3;
                    TJC.invoke(interp, null, objv2, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv2, 2);
                }
            } // End Invoke: incr
            TclObject tmp4 = interp.getResult();
            ExprValue tmp5 = TJC.exprGetValue(interp, tmp4);
            boolean tmp6 = tmp5.getBooleanValue(interp);
            TJC.exprReleaseValue(interp, tmp5);
            if ( tmp6 ) {
                interp.resetResult();
            } else {
                interp.resetResult();
            }
        } // End Invoke: if
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;
    TclObject const3;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("x");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(0);
        const2.preserve(); const2.preserve();
        const3 = TclString.newInstance("incr");
        const3.preserve(); const3.preserve();
    }
} // end class Test1
}}

# Cleanup
jdk_tool_cleanup
tcltest::cleanupTests

