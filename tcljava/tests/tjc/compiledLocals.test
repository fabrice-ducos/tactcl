# This file tests issues related to the CallFrame.compiledLocals
# array and the hashtable variable frame for compiled procs.
#
# Copyright (c) 2006 by Mo DeJong.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: compiledLocals.test,v 1.8 2006/05/15 01:25:46 mdejong Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

setupJavaPackage
package require TJC

proc clocals_tjc_compiled_proc { name } {
    global _clocals_tjc_ready

    TJC::compile $name -readyvar _clocals_tjc_ready
    vwait _clocals_tjc_ready
    if {[lindex $_clocals_tjc_ready 0] != "OK"} {
        puts stderr "could not compile $name : $_clocals_tjc_ready"
    }
    return
}

# Used to set traces on variables and determine
# if they were fired.

set compiled_local_trace_counter 0

proc compiled_local_trace_counter { args } {
    global compiled_local_trace_counter
    incr compiled_local_trace_counter
}


test compiledLocals-1.0 {uncompiled proc} {
    list [catch {testvarframe} err] $err
} {1 {can't be invoked from global scope}}

test compiledLocals-1.1 {uncompiled proc} {
    proc clocals_test11 {} {
        testvarframe
    }
    clocals_test11
} {localTable is null
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-1.2 {uncompiled proc} {
    proc clocals_test12 {A} {
        testvarframe
    }
    clocals_test12 1
} {localTable is {
A
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-1.3 {uncompiled proc} {
    proc clocals_test13 {} {
        set A 1
        testvarframe
    }
    clocals_test13
} {localTable is {
A
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-1.4 {uncompiled proc} {
    proc clocals_test14 {} {
        set A 1
        set B 2
        testvarframe
    }
    clocals_test14
} {localTable is {
A
B
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-1.5 {uncompiled proc} {
    catch {unset UNDEF}
    proc clocals_test15 {} {
        global UNDEF
        testvarframe
    }
    clocals_test15
} {localTable is {
UNDEFINED-> UNDEF -> ::UNDEF
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-1.6 {uncompiled proc} {
    catch {unset DEFINED}
    proc clocals_test16 {} {
        global DEFINED
        set DEFINED 1
        testvarframe
    }
    clocals_test16
} {localTable is {
DEFINED -> ::DEFINED
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-1.7 {uncompiled proc} {
    catch {unset ARR}
    set ARR(one) 1
    proc clocals_test17 {} {
        global ARR
        testvarframe
    }
    clocals_test17
} {localTable is {
ARR() -> ::ARR
}
compiledLocals is null
compiledLocals.resolved is null
}


# Note, these test are numbered in increasing order
# because of a bug in the TclClassLoader when combined
# with TJC::compile where a compiled command can't
# be compiled twice.

test compiledLocals-2.1 {compiled proc} {
    proc clocals_test21 {} {
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test21
    clocals_test21
} {localTable is null
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-2.2 {compiled proc} {
    proc clocals_test22 {A} {
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test22
    clocals_test22 1
} {localTable is null
compiledLocals is {
A
}
compiledLocals.resolved is {
A
}
}

test compiledLocals-2.3 {compiled proc} {
    proc clocals_test23 {} {
        set A 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test23
    clocals_test23
} {localTable is null
compiledLocals is {
A
}
compiledLocals.resolved is {
A
}
}

test compiledLocals-2.4 {compiled proc} {
    proc clocals_test24 {} {
        set A 1
        set B 2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test24
    clocals_test24
} {localTable is null
compiledLocals is {
A
B
}
compiledLocals.resolved is {
A
B
}
}

test compiledLocals-2.5 {compiled proc} {
    # This test shows that a compiled local
    # is allocated for the global variable
    # link, but it is not resolved since
    # the variable is undefined. Note also
    # that the local table is not initialized.
    catch {unset UNDEF}
    proc clocals_test25 {} {
        global UNDEF
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test25
    clocals_test25
} {localTable is null
compiledLocals is {
UNDEFINED-> UNDEF -> ::UNDEF
}
compiledLocals.resolved is {
!RESOLVED UNDEFINED UNDEF
}
}

test compiledLocals-2.6 {compiled proc} {
    # This test shows that setting an
    # undefined scalar that is linked to
    # a global variable will resolve
    # the compiledLocal ref to the scalar.
    catch {unset DEFINED}
    proc clocals_test26 {} {
        global DEFINED
        set DEFINED 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test26
    clocals_test26
} {localTable is null
compiledLocals is {
DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
}
}

test compiledLocals-2.7 {compiled proc} {
    # A variable set at runtime will
    # init the compiled local slot
    # because the runtime set command
    # will find the var by name in
    # the compiled local slot.
    proc clocals_test27 {} {
        eval {set i 0}
        set i
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test27
    clocals_test27
} {localTable is null
compiledLocals is {
i
}
compiledLocals.resolved is {
i
}
}

test compiledLocals-2.8 {compiled proc} {
    # The var j is set at runtime in the
    # compiled local array since it is
    # not in the compiled local array.
    # The var i is in the local array,
    # so it is defined there.
    proc clocals_test28 {} {
        eval {set i 0}
        eval {set j 0}
        return [testvarframe]
        set i 1
    }
    clocals_tjc_compiled_proc clocals_test28
    clocals_test28
} {localTable is {
j
}
compiledLocals is {
i
}
compiledLocals.resolved is {
i
}
}

test compiledLocals-2.9 {compiled proc} {
    # Unsetting a local table variable
    proc clocals_test29 {} {
        eval {set i 0}
        eval {unset i}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test29
    clocals_test29
} {localTable is {
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-2.10 {compiled proc} {
    # Unsetting a compiled local variable.
    # This implementation make sure to
    # use the runtime unset command, in
    # case the unset command is inlined.
    proc clocals_test210 {} {
        set i 0
        eval {unset i}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test210
    clocals_test210
} {localTable is null
compiledLocals is {
null
}
compiledLocals.resolved is {
null
}
}

test compiledLocals-2.11 {compiled proc} {
    # Unsetting a compiled local variable.
    proc clocals_test211 {} {
        set i 0
        unset i
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test211
    clocals_test211
} {localTable is null
compiledLocals is {
null
}
compiledLocals.resolved is {
null
}
}

test compiledLocals-2.12 {compiled proc} {
    # Unsetting a compiled local variable.
    proc clocals_test212 {} {
        set i 0
        unset i
        set i 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test212
    clocals_test212
} {localTable is null
compiledLocals is {
i
}
compiledLocals.resolved is {
i
}
}




test compiledLocals-3.0 {compiled proc} {
    # Variable set via foreach is placed
    # in the compiledLocals array.
    proc clocals_test30 {} {
        foreach V1 {1} {}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test30
    clocals_test30
} {localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
V1
}
}

test compiledLocals-3.1 {compiled proc} {
    # Variable set via catch is placed
    # into the compiledLocals array.
    proc clocals_test31 {} {
        catch {} ERR
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test31
    clocals_test31
} {localTable is null
compiledLocals is {
ERR
}
compiledLocals.resolved is {
ERR
}
}

test compiledLocals-3.2 {compiled proc} {
    # Use [info locals] to check that
    # compiled locals are being returned.
    proc clocals_test32 {} {
        set i 0
        set j 1
        info locals
    }
    clocals_tjc_compiled_proc clocals_test32
    lsort -dictionary [clocals_test32]
} {i j}

test compiledLocals-3.3 {compiled proc} {
    # Use [info locals] to check that
    # compiled locals are being returned.
    proc clocals_test33 {} {
        set i 0
        set j 1
        eval {set k 2}
        info locals
    }
    clocals_tjc_compiled_proc clocals_test33
    lsort -dictionary [clocals_test33]
} {i j k}

test compiledLocals-3.4 {compiled proc} {
    # Use [info locals] to check that
    # compiled locals are being returned.
    proc clocals_test34 {} {
        set i 0
        set j 1
        eval {set k 2}
        unset j
        info locals
    }
    clocals_tjc_compiled_proc clocals_test34
    lsort -dictionary [clocals_test34]
} {i k}


test compiledLocals-4.0 {link vars} {
    # global command will create a compiled
    # local scalar for a defined global.
    set DEFINED 1
    proc clocals_test40 {} {
        global DEFINED
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test40
    clocals_test40
} {localTable is null
compiledLocals is {
DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
}
}

test compiledLocals-4.1 {link vars} {
    # Invoking the global command twice for
    # the same variable name will be a no-op.
    set DEFINED 1
    proc clocals_test41 {} {
        global DEFINED
        global DEFINED
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test41
    clocals_test41
} {localTable is null
compiledLocals is {
DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
}
}

test compiledLocals-4.2 {link vars} {
    # Invoke global command at runtime,
    # this will create an undefined link var
    # in the local table since no compiled
    # local slot is for this variable
    # was declared.
    set DEFINED 1
    proc clocals_test42 {} {
        eval {global DEFINED}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test42
    clocals_test42
} {localTable is {
DEFINED -> ::DEFINED
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.3 {link vars} {
    # Invoke global command at runtime to
    # add a link var. The link var will
    # get added in the compiled local
    # slot even though the uncompiled
    # version of the global command
    # is being used.

    set DEFINED 1
    proc clocals_test43 {} {
        eval {global DEFINED}
        return [testvarframe]
        set DEFINED 2
    }
    clocals_tjc_compiled_proc clocals_test43
    clocals_test43
} {localTable is null
compiledLocals is {
DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
}
}

test compiledLocals-4.4 {link vars} {
    # Invoke upvar to link var into the
    # global scope. This will create the
    # variable in the local table since
    # the upvar command is not compiled
    # and no compiled local slot is
    # declared for the variable name.
    catch {unset UNDEF}
    proc clocals_test44 {} {
        upvar #0 UNDEF lvar
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test44
    clocals_test44
} {localTable is {
UNDEFINED-> lvar -> ::UNDEF
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.5 {link vars} {
    # Invoke upvar to create a link var in
    # the local table.
    proc clocals_test45 {} {
        set V1 0
        upvar 0 V1 V2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test45
    clocals_test45
} {localTable is {
V2 -> V1
}
compiledLocals is {
V1
}
compiledLocals.resolved is {
V1
}
}

test compiledLocals-4.6 {link vars} {
    # Invoke upvar to create a link var.
    # The link var is a compiled local,
    # so create it in the compiled
    # local array.
    proc clocals_test46 {} {
        set V1 0
        upvar 0 V1 V2
        return [testvarframe]
        set V2 1
    }
    clocals_tjc_compiled_proc clocals_test46
    clocals_test46
} {localTable is null
compiledLocals is {
V1
V2 -> V1
}
compiledLocals.resolved is {
V1
V1
}
}

test compiledLocals-4.7 {link vars} {
    # Invoke upvar to create a link var in
    # the local table. Then create a
    # second link to the same variable
    # with a compiled local var name.
    proc clocals_test47 {} {
        set V1 0
        upvar 0 V1 V2
        upvar 0 V2 V3
        set V3 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test47
    clocals_test47
} {localTable is {
V2 -> V1
}
compiledLocals is {
V1
V3 -> V1
}
compiledLocals.resolved is {
V1
V1
}
}

test compiledLocals-4.8 {link vars} {
    # Invoke upvar to create a link var
    # to an array element.
    proc clocals_test48 {} {
        set ARR(one) 1
        upvar 0 ARR(one) var
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test48
    clocals_test48
} {localTable is {
var -> ?()
}
compiledLocals is {
ARR()
}
compiledLocals.resolved is {
ARR()
}
}

test compiledLocals-4.9 {link vars} {
    # Invoke upvar to create a link var
    # to an array element and then set it
    # to add the link var into the
    # compiledLocals array. It should
    # not be possible to resolve the link
    # var since the scalar is an array
    # element.
    proc clocals_test49 {} {
        set ARR(one) 1
        upvar 0 ARR(one) var
        set var 2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test49
    clocals_test49
} {localTable is null
compiledLocals is {
ARR()
var -> ?()
}
compiledLocals.resolved is {
ARR()
!RESOLVED one
}
}

test compiledLocals-4.10 {link vars} {
    # Upvar link to local variable that
    # does not exist is valid.
    proc clocals_test410 {} {
        upvar 0 notyet var
        set var 2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test410
    clocals_test410
} {localTable is {
notyet
}
compiledLocals is {
var -> notyet
}
compiledLocals.resolved is {
notyet
}
}

test compiledLocals-4.11 {link vars} {
    # Create 2 local variables
    # that link to the same
    # global scalar variable.

    catch {unset DEFINED}
    set DEFINED 1
    proc clocals_test411 {} {
        upvar #0 DEFINED var1
        upvar #0 DEFINED var2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test411
    clocals_test411
} {localTable is {
var1 -> ::DEFINED
var2 -> ::DEFINED
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.12 {link vars} {
    # Create upvar link to a global
    # variable, then redirect the
    # upvar link to a local scalar.
    # This checks for the link var
    # in same table special case
    # in Var.deleteVar().
    # This proc is not compiled.

    proc clocals_test412 {} {
        upvar 0 dummy_local1 var1
        upvar 0 dummy_local2 var1
        testvarframe
    }
    clocals_test412
} {localTable is {
UNDEFINED-> var1 -> dummy_local2
UNDEFINED dummy_local2
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.13 {link vars} {
    # Create upvar link to a global
    # variable, then redirect the
    # upvar link to a local scalar.
    # This checks for the link var
    # in same table special case
    # in Var.deleteVar().
    # This proc is compiled.

    proc clocals_test413 {} {
        upvar 0 dummy_local1 var1
        upvar 0 dummy_local2 var1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test413
    clocals_test413
} {localTable is {
UNDEFINED-> var1 -> dummy_local2
UNDEFINED dummy_local2
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.14 {link vars} {
    # Create upvar link to a global
    # variable, then redirect the
    # upvar link to a local scalar.
    # This checks for the link var
    # in same table special case
    # in Var.deleteVar().
    # This proc is compiled.

    proc clocals_test414 {} {
        set dummy_local1 1
        set dummy_local2 2
        upvar 0 dummy_local1 var1
        upvar 0 dummy_local2 var1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test414
    clocals_test414
} {localTable is {
var1 -> dummy_local2
}
compiledLocals is {
dummy_local1
dummy_local2
}
compiledLocals.resolved is {
dummy_local1
dummy_local2
}
}

test compiledLocals-4.15 {link vars} {
    # Create upvar link to a global
    # variable, then redirect the
    # upvar link to a local scalar.
    # This proc is not compiled.

    catch {unset DEFINED}
    set DEFINED 1
    proc clocals_test415 {} {
        upvar #0 DEFINED var1
        upvar 0 dummy_local var1
        testvarframe
    }
    clocals_test415
} {localTable is {
UNDEFINED-> var1 -> dummy_local
UNDEFINED dummy_local
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.16 {link vars} {
    # Create upvar link to a global
    # variable, then redirect the
    # upvar link to a local scalar
    # in the compiledLocals array.
    # This proc is compiled.

    catch {unset DEFINED}
    set DEFINED 1
    proc clocals_test416 {} {
        set L1 1
        upvar #0 DEFINED var1
        upvar 0 L1 var1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test416
    clocals_test416
} {localTable is {
var1 -> L1
}
compiledLocals is {
L1
}
compiledLocals.resolved is {
L1
}
}

test compiledLocals-4.17 {link vars} {
    # Create upvar link to a local
    # variable in the compiledLocals
    # array. Then redirect to another
    # local variable in the compiled
    # locals array.
    # This proc is compiled.

    proc clocals_test417 {} {
        set L1 1
        set L2 2
        upvar 0 L1 var1
        upvar 0 L2 var1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test417
    clocals_test417
} {localTable is {
var1 -> L2
}
compiledLocals is {
L1
L2
}
compiledLocals.resolved is {
L1
L2
}
}

test compiledLocals-4.18 {link vars} {
    # Upvar can't replace an existing
    # local var. This proc is not compiled.

    proc clocals_test418 {} {
        set L1 1
        upvar 0 dummy L1
    }
    list [catch {clocals_test418} err] $err
} {1 {variable "L1" already exists}}

test compiledLocals-4.19 {link vars} {
    # Upvar can't replace an existing
    # local var. This proc is compiled.

    proc clocals_test419 {} {
        set L1 1
        upvar 0 dummy L1
    }
    clocals_tjc_compiled_proc clocals_test419
    list [catch {clocals_test419} err] $err
} {1 {variable "L1" already exists}}

test compiledLocals-4.20 {link vars} {
    # Create upvar link to a global
    # variable, then create a second
    # upvar link to the same global.
    # Then, replace the second link
    # with a link to a compiled local.
    # This proc is compiled.

    catch {unset DEFINED}
    set DEFINED 1

    proc clocals_test420 {} {
        set L1 "HI"
        upvar #0 DEFINED var
        upvar #0 DEFINED local_ref
        upvar 0 L1 local_ref
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test420
    clocals_test420
} {localTable is {
var -> ::DEFINED
local_ref -> L1
}
compiledLocals is {
L1
}
compiledLocals.resolved is {
L1
}
}

test compiledLocals-4.21 {link vars} {
    # global command creates a linked
    # from var in the local table.
    catch {unset DEFINED}
    set DEFINED YES
    proc clocals_test421 {} {
        global DEFINED
        testvarframe
    }
    clocals_test421
} {localTable is {
DEFINED -> ::DEFINED
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.22 {link vars} {
    # global command creates a linked from
    # var in the local table.
    # This linked from var is marked
    # as undefined if the global is unset.
    catch {unset DEFINED}
    set DEFINED YES
    proc clocals_test422 {} {
        global DEFINED
        namespace eval :: {unset DEFINED}
        testvarframe
    }
    clocals_test422
} {localTable is {
UNDEFINED-> DEFINED -> ::DEFINED
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-4.23 {link vars} {
    # global command creates a linked from
    # var in the compiled local array.
    catch {unset DEFINED}
    set DEFINED YES
    proc clocals_test423 {} {
        global DEFINED
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test423
    clocals_test423
} {localTable is null
compiledLocals is {
DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
}
}

test compiledLocals-4.24 {link vars} {
    # Unsetting the linked to var
    # linked from a compiled local.
    # This shows how the undefined flag is
    # set on the linked to Var.
    # Because the undefined flag is
    # set, the scalar can't be resolved.
    catch {unset DEFINED}
    set DEFINED YES
    proc clocals_test424 {} {
        global DEFINED
        namespace eval :: {unset DEFINED}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test424
    clocals_test424
} {localTable is null
compiledLocals is {
UNDEFINED-> DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
!RESOLVED UNDEFINED DEFINED
}
}

test compiledLocals-4.25 {link vars} {
    # Define a local linked var,
    # then unset the linked to
    # var in the global namespace.
    # Setting the local to a new
    # value should invoke the
    # runtime set and update the
    # linked to global var.
    catch {unset DEFINED}
    set DEFINED YES
    proc clocals_test425 {} {
        global DEFINED
        namespace eval :: {unset DEFINED}
        set DEFINED RESET
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test425
    clocals_test425
} {localTable is null
compiledLocals is {
DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
}
}

test compiledLocals-4.26 {link vars} {
    # Unsetting the linked from
    # var should unset the linked
    # to var but keep the link from
    # Var in the compiled locals array.

    catch {unset DEFINED}
    set DEFINED YES
    proc clocals_test426 {} {
        global DEFINED
        unset DEFINED
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test426
    clocals_test426
} {localTable is null
compiledLocals is {
UNDEFINED-> DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
!RESOLVED UNDEFINED DEFINED
}
}

test compiledLocals-4.27 {link vars} {
    # Unsetting a compiled local
    # that is linked to by a link
    # var should not null out the
    # compiled local slot since
    # the Var ref count will be
    # non-zero.

    proc clocals_test427 {} {
        set V1 1
        upvar 0 V1 V2
        eval {unset V1}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test427
    clocals_test427
} {localTable is {
UNDEFINED-> V2 -> V1
}
compiledLocals is {
UNDEFINED V1
}
compiledLocals.resolved is {
!RESOLVED UNDEFINED V1
}
}

test compiledLocals-4.28 {link vars} {
    # An upvar can't replace an existing
    # local variable. This command
    # in uncompiled.
    proc clocals_test428 {} {
        set VAR 0
        upvar 0 dummy VAR
    }
    list [catch {clocals_test428} err] $err
} {1 {variable "VAR" already exists}}

test compiledLocals-4.29 {link vars} {
    # An upvar can't replace an existing
    # local variable. This test makes
    # sure the local table is checked
    # when compiled.
    proc clocals_test429 {} {
        eval {set VAR 0}
        upvar 0 dummy VAR
    }
    clocals_tjc_compiled_proc clocals_test429
    list [catch {clocals_test429} err] $err
} {1 {variable "VAR" already exists}}

test compiledLocals-4.30 {link vars} {
    # An upvar can't replace an existing
    # local variable. This test makes
    # sure that the compiled local array
    # is checked.
    proc clocals_test430 {} {
        set VAR 0
        upvar 0 dummy VAR
    }
    clocals_tjc_compiled_proc clocals_test430
    list [catch {clocals_test430} err] $err
} {1 {variable "VAR" already exists}}

test compiledLocals-4.31 {link vars} {
    # A global can't replace an existing
    # local variable. This command is
    # uncompiled.
    proc clocals_test431 {} {
        set VAR 0
        global VAR
    }
    list [catch {clocals_test431} err] $err
} {1 {variable "VAR" already exists}}

test compiledLocals-4.32 {link vars} {
    # A global can't replace an existing
    # local variable. This test makes
    # sure the local table is checked.
    proc clocals_test432 {} {
        eval {set VAR 0}
        global VAR
    }
    clocals_tjc_compiled_proc clocals_test432
    list [catch {clocals_test432} err] $err
} {1 {variable "VAR" already exists}}

test compiledLocals-4.33 {link vars} {
    # A global can't replace an existing
    # local variable. This test makes
    # sure the compiled local array slot
    # is checked.
    proc clocals_test433 {} {
        set VAR 0
        global VAR
    }
    clocals_tjc_compiled_proc clocals_test433
    list [catch {clocals_test433} err] $err
} {1 {variable "VAR" already exists}}

test compiledLocals-4.34 {link vars} {
    # Duplicate global commands is
    # a no-op. It does not matter
    # that the first global command
    # is uncompiled.
    proc clocals_test434 {} {
        eval {global UNKNOWN}
        global UNKNOWN
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test434
    clocals_test434
} {localTable is null
compiledLocals is {
UNDEFINED-> UNKNOWN -> ::UNKNOWN
}
compiledLocals.resolved is {
!RESOLVED UNDEFINED UNKNOWN
}
}


test compiledLocals-5.0 {local array variables} {
    proc clocals_test50 {} {
        set ARR(one) 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test50
    clocals_test50
} {localTable is null
compiledLocals is {
ARR()
}
compiledLocals.resolved is {
ARR()
}
}

test compiledLocals-5.1 {local array variables} {
    # use local table when uncompiled
    catch {unset ARR}
    set ARR(one) 1
    proc clocals_test51 {} {
        global ARR
        testvarframe
    }
    clocals_test51
} {localTable is {
ARR() -> ::ARR
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-5.2 {local array variables} {
    # This test shows how the global command
    # will add a linked var to the compiled
    # local array.
    catch {unset ARR}
    set ARR(one) 1
    proc clocals_test52 {} {
        global ARR
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test52
    clocals_test52
} {localTable is null
compiledLocals is {
ARR() -> ::ARR
}
compiledLocals.resolved is {
ARR()
}
}

test compiledLocals-5.3 {local array variables} {
    # This test should show how a local array
    # variable can be linked to via upvar.
    proc clocals_test53 {} {
        set arr(one) 1
        upvar 0 arr var
        set var(one) 2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test53
    clocals_test53
} {localTable is null
compiledLocals is {
arr()
var() -> arr
}
compiledLocals.resolved is {
arr()
arr()
}
}

test compiledLocals-5.4 {local array variables} {
    # Local scalar and array variables have
    # the same name. Should make use of the
    # same compiled local slot, the runtime
    # would raise an error if scalar was accessed
    # as an array or array accessed as a scalar.
    proc clocals_test54 {} {
        set a 1
        return [testvarframe]
        set a(b) 2
    }
    clocals_tjc_compiled_proc clocals_test54
    clocals_test54
} {localTable is null
compiledLocals is {
a
}
compiledLocals.resolved is {
a
}
}

test compiledLocals-5.5 {local array variables} {
    # Local scalar and array variables have
    # the same name. Should make use of the
    # same compiled local slot, the runtime
    # would raise an error if scalar was accessed
    # as an array or array accessed as a scalar.
    proc clocals_test55 {} {
        set a(b) 2
        return [testvarframe]
        set a 1
    }
    clocals_tjc_compiled_proc clocals_test55
    clocals_test55
} {localTable is null
compiledLocals is {
a()
}
compiledLocals.resolved is {
a()
}
}

test compiledLocals-5.6 {local array variables} {
    # Attempt to set array variable with
    # non-static key.
    proc clocals_test56 {} {
        set key name
        set a($key) bob
        return [testvarframe]
    }
    clocals_tjc_compiled_proc clocals_test56
    clocals_test56
} {localTable is null
compiledLocals is {
key
a()
}
compiledLocals.resolved is {
key
a()
}
}

test compiledLocals-5.7 {local array variables} {
    # Attempt to get array variable with
    # non-static key.
    proc clocals_test57 {} {
        set a(name) bob
        set key name
        set a($key)
        return [testvarframe]
    }
    clocals_tjc_compiled_proc clocals_test57
    clocals_test57
} {localTable is null
compiledLocals is {
a()
key
}
compiledLocals.resolved is {
a()
key
}
}



test compileLocals-6.0 {var traces} {
    # Setting a trace on a compiled
    # local scalar will define the
    # TRACE_EXISTS flag. This will
    # keep the scalar from being resolved.

    proc clocals_test60 {} {
        set V1 0
        trace variable V1 w compiled_local_trace_counter
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test60
    clocals_test60
} {localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
!RESOLVED V1 TRACE_EXISTS
}
}

test compileLocals-6.1 {var traces} {
    # This test checks that traces
    # are fired for variables. The
    # compiled var impl should not
    # use a resolved var ref
    # when a trace is set on a
    # variable.

    set compiled_local_trace_counter 0

    proc clocals_test61 {} {
        set V1 0
        trace variable V1 w compiled_local_trace_counter
        set V1 2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test61
    list [clocals_test61] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
!RESOLVED V1 TRACE_EXISTS
}
} 1}

test compileLocals-6.2 {var traces} {
    # This test sets a trace on a
    # variable that was created at
    # runtime. The compiled local
    # slot should be initialized,
    # and the trace should keep
    # the scalar from being resolved.

    set compiled_local_trace_counter 0

    proc clocals_test62 {} {
        eval {set V1 0}
        trace variable V1 w compiled_local_trace_counter
        set V1 2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test62
    list [clocals_test62] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
!RESOLVED V1 TRACE_EXISTS
}
} 1}

test compileLocals-6.3 {var traces} {
    # This test checks that a read
    # trace is not run when a compiled
    # local is set. The read trace
    # was created when no var existed,
    # so it initialized a compiled
    # local slot.

    set compiled_local_trace_counter 0

    proc clocals_test63 {} {
        trace variable V1 r compiled_local_trace_counter
        set V1 0
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test63
    list [clocals_test63] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
!RESOLVED V1 TRACE_EXISTS
}
} 0}

test compileLocals-6.4 {var traces} {
    # This test checks that a read
    # trace is run when a compiled
    # local is read from a set
    # command executed at runtime.
    # The trace command creates
    # a scalar var in the compiled
    # local array. It is later read
    # from a runtime set command.

    set compiled_local_trace_counter 0

    proc clocals_test64 {} {
        trace variable V1 r compiled_local_trace_counter
        set V1 0
        eval {set V1}
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test64
    list [clocals_test64] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
!RESOLVED V1 TRACE_EXISTS
}
} 1}

test compileLocals-6.5 {var traces} {
    # This test checks that a read
    # trace that defines a global
    # variable is run when a variable
    # is accessed. The global needs
    # to be defined for clocals_test65
    # to finish without an error.

    catch {unset clocals_test65_trace_var}

    proc clocals_test65_trace { args } {
        global clocals_test65_trace_var
        set clocals_test65_trace_var 1
    }

    proc clocals_test65 {} {
        upvar #0 clocals_test65_trace_var var
        trace variable var r clocals_test65_trace
        set var
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test65
    clocals_test65
} {localTable is null
compiledLocals is {
var -> ::clocals_test65_trace_var
}
compiledLocals.resolved is {
!RESOLVED clocals_test65_trace_var TRACE_EXISTS
}
}

test compileLocals-6.6 {var traces} {
    # This test checks that a write
    # trace is run when a compiled
    # local linked to a global
    # is set. The scalar set code
    # must check for an invalid
    # link to resolved link for this
    # to work.

    set compiled_local_trace_counter 0
    set clocals_test66_var YES

    proc clocals_test66 {} {
        global clocals_test66_var
        namespace eval :: {
            trace variable clocals_test66_var w compiled_local_trace_counter
        }
        set clocals_test66_var NO
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test66
    list [clocals_test66] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
clocals_test66_var -> ::clocals_test66_var
}
compiledLocals.resolved is {
!RESOLVED clocals_test66_var TRACE_EXISTS
}
} 1}

test compileLocals-6.7 {var traces} {
    # This test checks that a read
    # trace is run when a compiled
    # local linked to a global
    # is read. The scalar get code
    # must check for an invalid
    # link to resolved link for this
    # to work.

    set compiled_local_trace_counter 0
    set clocals_test67_var YES

    proc clocals_test67 {} {
        global clocals_test67_var
        namespace eval :: {
            trace variable clocals_test67_var r compiled_local_trace_counter
        }
        list $clocals_test67_var
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test67
    list [clocals_test67] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
clocals_test67_var -> ::clocals_test67_var
}
compiledLocals.resolved is {
!RESOLVED clocals_test67_var TRACE_EXISTS
}
} 1}

test compileLocals-6.8 {var traces} {
    # This test shows how setting
    # a trace on the linked to var
    # will cause the resolve step
    # to return null because the
    # scalar is now invalid.

    set compiled_local_trace_counter 0
    set clocals_test68_var YES

    proc clocals_test68 {} {
        global clocals_test68_var
        namespace eval :: {
            trace variable clocals_test68_var r compiled_local_trace_counter
        }
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test68
    list [clocals_test68] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
clocals_test68_var -> ::clocals_test68_var
}
compiledLocals.resolved is {
!RESOLVED clocals_test68_var TRACE_EXISTS
}
} 0}

test compileLocals-6.9 {var traces} {
    # This test checks that a read
    # trace set on the array variable
    # is run when the array element
    # is accessed. The array var
    # logic will see the resolved
    # variable as valid even when
    # traces exist on the var.

    set compiled_local_trace_counter 0

    proc clocals_test69 {} {
        set arr(one) 1
        set arr(two) 1
        trace variable arr r compiled_local_trace_counter
        set arr(one)
        set arr(two)
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test69
    list [clocals_test69] $compiled_local_trace_counter
} {{localTable is null
compiledLocals is {
arr()
}
compiledLocals.resolved is {
arr() TRACE_EXISTS
}
} 2}

test compileLocals-6.10 {var traces} {
    # Creating and then deleting a
    # trace on a local variable should
    # clear the TRACE_EXISTS flag.

    proc clocals_test610 {} {
        set V1 0
        trace variable V1 w compiled_local_trace_counter
        trace vdelete V1 w compiled_local_trace_counter
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test610
    clocals_test610
} {localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
V1
}
}

test compileLocals-6.11 {var traces} {
    # Creating two traces and then
    # deleting one of them should not
    # clear the TRACE_EXISTS flag.

    proc clocals_test611 {} {
        set V1 0
        trace variable V1 w compiled_local_trace_counter
        trace variable V1 r compiled_local_trace_counter
        trace vdelete V1 w compiled_local_trace_counter
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test611
    clocals_test611
} {localTable is null
compiledLocals is {
V1
}
compiledLocals.resolved is {
!RESOLVED V1 TRACE_EXISTS
}
}

test compileLocals-6.12 {var traces} {
    # Defining a trace on a local var
    # and then deleting it should
    # clear the TRACE_EXISTS flag.
    # That should set the var.traces
    # field to null, check this by
    # attempting to overwrite the
    # local var with a link var.
    # If the var.traces field is
    # non-null, then this upvar
    # will generate an error.
    # The bug that caused this has
    # been fixed, as the var.traces
    # field is now set to null and
    # the flag is cleared when the
    # last trace is deleted.

    proc clocals_test612 {} {
        trace variable V1 w compiled_local_trace_counter
        trace vdelete V1 w compiled_local_trace_counter
        upvar 0 dummy_local V1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test612
    clocals_test612
} {localTable is {
UNDEFINED-> V1 -> dummy_local
UNDEFINED dummy_local
}
compiledLocals is null
compiledLocals.resolved is null
}



test compileLocals-7.0 {scoped variable names} {
    # This test shows how a global variable
    # can be accessed from inside a proc
    # using the scoped var resolution syntax.
    # This proc is uncompiled.

    set clocals_test70_var 1

    proc clocals_test70 {} {
        list $::clocals_test70_var
        testvarframe
    }
    clocals_test70
} {localTable is null
compiledLocals is null
compiledLocals.resolved is null
}

test compileLocals-7.1 {scoped variable names} {
    # This test shows how a global variable
    # can be accessed from inside a proc
    # using the scoped var resolution syntax.

    set clocals_test71_var 1

    proc clocals_test71 {} {
        list $::clocals_test71_var
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test71
    clocals_test71
} {localTable is null
compiledLocals is {
Non-Local ::clocals_test71_var -> ::clocals_test71_var
}
compiledLocals.resolved is {
clocals_test71_var
}
}

test compileLocals-7.2 {scoped variable names} {
    # This test shows how a global variable
    # can be set from inside a proc
    # using the scoped var resolution syntax.

    set clocals_test72_var 1

    proc clocals_test72 {} {
        set ::clocals_test72_var VALUE
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test72
    clocals_test72
} {localTable is null
compiledLocals is {
Non-Local ::clocals_test72_var -> ::clocals_test72_var
}
compiledLocals.resolved is {
clocals_test72_var
}
}

test compileLocals-7.3 {scoped variable names} {
    # Use global command to create a link
    # var to a scoped value. This should
    # not find the global var with the
    # tail part.

    catch {namespace delete ONE}

    set CLOCAL_TEST_73_SCOPED BAD

    namespace eval ::ONE {}
    set ::ONE::CLOCAL_TEST_73_SCOPED GOOD

    proc clocals_test73 {} {
        global ::ONE::CLOCAL_TEST_73_SCOPED
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test73
    set results [clocals_test73]
    namespace delete ONE
    unset CLOCAL_TEST_73_SCOPED
    set results
} {localTable is null
compiledLocals is {
CLOCAL_TEST_73_SCOPED -> ::ONE::CLOCAL_TEST_73_SCOPED
}
compiledLocals.resolved is {
CLOCAL_TEST_73_SCOPED
}
}

test compileLocals-7.4 {scoped variable names} {
    # This test uses info local to make sure
    # that the non-local compiledLocals var
    # is not returned.

    set clocals_test74_var 1

    proc clocals_test74 {} {
        set ::clocals_test74_var VALUE
        set j 0
        eval {set k 2}
        info locals
    }
    clocals_tjc_compiled_proc clocals_test74
    lsort [clocals_test74]
} {j k}

test compileLocals-7.5 {scoped variable names} {
    # This test check that a local and a
    # scoped global with the exact same
    # name is handled properly.

    catch {unset DEFINED}
    set DEFINED 1

    proc clocals_test75 {} {
        set DEFINED 2
        set ::DEFINED 3
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test75
    clocals_test75
} {localTable is null
compiledLocals is {
DEFINED
Non-Local ::DEFINED -> ::DEFINED
}
compiledLocals.resolved is {
DEFINED
DEFINED
}
}

test compileLocals-7.6 {scoped variable names} {
    # Scoped scalar name that is a relative
    # namespace qualifier. This type is not
    # added to the compiled locals.

    namespace eval ::ONE {}
    set ::ONE::V1 0
    set ::ONE::V2 0

    proc clocals_test76 {} {
        set ONE::V1 1
        set ONE::V2
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test76
    set results [clocals_test76]
    namespace delete ONE
    set results
} {localTable is null
compiledLocals is null
compiledLocals.resolved is null
}

test compileLocals-7.7 {scoped variable names} {
    # A scoped scalar variable is accessed
    # and then unset and set again. The last
    # set command should resolve the
    # scoped scalar to the newly set var.

    namespace eval ::ONE {}
    set ::ONE::VAR 1

    proc clocals_test77 {} {
        set ::ONE::VAR
        namespace eval :: {
            unset ::ONE::VAR
            set ::ONE::VAR 2
        }
        set ::ONE::VAR 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test77
    set results [clocals_test77]
    namespace delete ONE
    set results
} {localTable is null
compiledLocals is {
Non-Local ::ONE::VAR -> ::ONE::VAR
}
compiledLocals.resolved is {
VAR
}
}

test compileLocals-7.8 {scoped variable names} {
    # A scoped scalar variable is accessed
    # relative to the current namespace.

    namespace eval ::ONE {
        namespace eval child1 {}
    }
    set ::ONE::child1::V1 9

    proc ::ONE::clocals_test78 {} {
        set child1::V1
        testvarframe
    }
    clocals_tjc_compiled_proc ::ONE::clocals_test78
    set results [::ONE::clocals_test78]
    namespace delete ::ONE
    set results
} {localTable is null
compiledLocals is null
compiledLocals.resolved is null
}

test compileLocals-7.9 {scoped variable names} {
    # Use global command to replace a compiled
    # local link var with another link var.
    # This should not see the global named VAR.

    catch {namespace delete ONE}
    catch {namespace delete TWO}

    set VAR BAD

    namespace eval ::ONE {}
    namespace eval ::TWO {}
    set ::ONE::VAR 1
    set ::TWO::VAR 2

    proc clocals_test79 {} {
        global ::ONE::VAR
        global ::TWO::VAR
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test79
    set results [clocals_test79]
    namespace delete ONE TWO
    set results
} {localTable is null
compiledLocals is {
VAR -> ::TWO::VAR
}
compiledLocals.resolved is {
VAR
}
}



test compileLocals-8.0 {upvar to local vars in caller frame} {
    # This test invokes a subcommand
    # which creates an upvar link
    # into the calling frame. The
    # var V1 in the calling frame
    # is then unset.

    proc clocals_test80 {} {
        set V1 "zero"
        clocals_test80_sub
        testvarframe
    }
    proc clocals_test80_sub {} {
        upvar 1 V1 local
        uplevel 1 {unset V1}
        uplevel 1 testvarframe
    }

    clocals_test80
} {localTable is {
}
compiledLocals is null
compiledLocals.resolved is null
}

test compileLocals-8.1 {upvar to local vars in caller frame} {
    # This test invokes a subcommand
    # which creates an upvar link
    # into the calling frame. The
    # var V1 in the calling frame
    # is unset when the link var
    # is unset in the calling frame.

    # If the Var class was able to
    # set its own compiled local to
    # null, then this would show
    # null in the compiledLocals slot.

    proc clocals_test81 {} {
        set V1 "zero"
        clocals_test81_sub
        testvarframe
    }
    proc clocals_test81_sub {} {
        upvar 1 V1 local
        unset local
    }

    clocals_tjc_compiled_proc clocals_test81
    clocals_test81
} {localTable is null
compiledLocals is {
UNDEFINED V1
}
compiledLocals.resolved is {
!RESOLVED UNDEFINED V1
}
}

test compileLocals-8.2 {upvar to local vars in caller frame} {
    # This test invokes a subcommand
    # which creates an upvar link
    # into the calling frame. The
    # var V1 in the calling frame
    # is then unset via uplevel.

    proc clocals_test82 {} {
        set V1 "zero"
        clocals_test82_sub
        testvarframe
    }
    proc clocals_test82_sub {} {
        uplevel 1 {unset V1}
    }

    clocals_tjc_compiled_proc clocals_test82
    clocals_test82
} {localTable is null
compiledLocals is {
null
}
compiledLocals.resolved is {
null
}
}

test compileLocals-8.3 {upvar to local vars in same frame} {
    # This test creates an upvar link in the
    # local frame. The var is defined at runtime,
    # so it lives in the local table.

    proc clocals_test83 {} {
        set V1 0
        eval {upvar 0 V1 local}
        testvarframe
    }

    clocals_tjc_compiled_proc clocals_test83
    clocals_test83
} {localTable is {
local -> V1
}
compiledLocals is {
V1
}
compiledLocals.resolved is {
V1
}
}


test compiledLocals-9.0 {lappend} {
    # lappend for undefined scalar var
    # invokes runtime lappend command.
    # Since l is a compiled local, the
    # runtime lappend command will
    # create it in the compiled local
    # array.
    proc clocals_test90 {} {
        lappend l 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test90
    clocals_test90
} {localTable is null
compiledLocals is {
l
}
compiledLocals.resolved is {
l
}
}

test compiledLocals-9.1 {lappend} {
    # lappend for an undefined
    # array variable will invoke
    # the runtime set to create
    # the array and the array element.
    # The array will be created in
    # the compiled local slot since
    # the slot is search for by name.
    proc clocals_test91 {} {
        lappend a(k) 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test91
    clocals_test91
} {localTable is null
compiledLocals is {
a()
}
compiledLocals.resolved is {
a()
}
}

test compiledLocals-9.2 {lappend} {
    # lappend for an undefined
    # array variable should set
    # the array and the array
    # element. This version
    # will not add an entry to
    # the compiled local array
    # since a 2 argument lappend
    # is not compiled.
    proc clocals_test92 {} {
        lappend a(k)
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test92
    clocals_test92
} {localTable is {
a()
}
compiledLocals is null
compiledLocals.resolved is null
}

test compiledLocals-9.3 {lappend} {
    # lappend for an array variable
    # that is defined but does not
    # contain the array element
    # will set the array element.
    proc clocals_test93 {} {
        set a(k2) 1
        lappend a(k) 1
        testvarframe
    }
    clocals_tjc_compiled_proc clocals_test93
    clocals_test93
} {localTable is null
compiledLocals is {
a()
}
compiledLocals.resolved is {
a()
}
}

test compiledLocals-9.4 {array} {
    # array set comamnd will
    # init a compiled local slot
    # for the array variable.
    proc clocals_test94 {} {
        array set a {one 1 two 2}
        return [testvarframe]
        set a(one)
    }
    clocals_tjc_compiled_proc clocals_test94
    clocals_test94
} {localTable is null
compiledLocals is {
a()
}
compiledLocals.resolved is {
a()
}
}


# When testing array vars, make sure to implement
# a compiled version of [array set FOO {one 1 two 2}]
# that will define the array in the compiledLocals
# array of Var values.

# compiled local scalars with an absolute
# namespace qualifier might only be used
# once. Implement a test during scan keys
# so that the containment stack can be
# determined to see if a given command is
# executed in a loop. That way, a scoped
# var that is only used once and not inside
# a loop would not need to be added to the
# compiled local array. It could just be
# looked up once since that is faster than
# creating a link var.




# Test series 10 checks both uncompiled expr
# commands and optimized expr operations.
# These tests check the internal TclObject
# type before and after expr operations.

proc irep { obj } {
    return [java::call tcl.lang.TestTcl internalRepToString $obj]
}

proc irepto { obj } {
    list \
        [java::call tcl.lang.TestTcl internalRepToString $obj] \
        [java::call tcl.lang.TestTcl toString $obj]
}

proc tostring { obj } {
    return [java::call tcl.lang.TestTcl toString $obj]
}

proc norep { obj } {
    return [java::call tcl.lang.TestTcl hasNoStringRep $obj]
}

test compiledLocals-10.0 {expr} {
    # This test shows that an uncompiled local
    # starts life as a TclString and is converted
    # to a TclInteger by the expr command.
    proc clocals_test10_0 {} {
        set V 1

        set results [list]
        lappend results [irepto $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irepto $V]
        return $results
    }
    clocals_test10_0
} {{TclString 1} {expr 1} {TclInteger 1}}

test compiledLocals-10.1 {expr} {
    # compiled local starts life as TclInteger
    proc clocals_test10_1 {} {
        set V 1

        set results [list]
        lappend results [irepto $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_1
    clocals_test10_1
} {{TclInteger 1} {expr 1} {TclInteger 1}}

test compiledLocals-10.2 {expr} {
    # This compiled local is created from
    # a word, so it is not a TclInteger.
    proc clocals_test10_2 {} {
        set p1 ""
        set p2 "1"
        set V "${p1}${p2}"

        set results [list]
        lappend results [irepto $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_2
    clocals_test10_2
} {{TclString 1} {expr 1} {TclInteger 1}}

test compiledLocals-10.3 {expr} {
    # This compiled local does not start
    # out as a TclInteger, it is converted
    # to one by the incr command. The incr
    # command will also invalidate the
    # string rep.
    proc clocals_test10_3 {} {
        set p1 " "
        set p2 "1"
        set V "$p1$p2"

        set results [list]
        lappend results [irepto $V]
        incr V 0
        lappend results [irepto $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_3
    clocals_test10_3
} {{TclString { 1}} {TclInteger 1} {expr 1} {TclInteger 1}}

test compiledLocals-10.4 {expr} {
    # This compiled local starts life
    # as a TclInteger with a string
    # rep containing a space. The expr
    # operation does not invalidate the
    # string rep.
    proc clocals_test10_4 {} {
        set V " 1"

        set results [list]
        lappend results [irepto $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_4
    clocals_test10_4
} {{TclInteger { 1}} {expr 1} {TclInteger { 1}}}

test compiledLocals-10.5 {expr} {
    # Compiled local is not a TclInteger,
    # it is converted from a TclString to
    # a TclInteger by the expr command.
    proc clocals_test10_5 {} {
        set V [string range "2" 0 end]

        set results [list]
        lappend results [irepto $V]
        lappend results [list "expr" [expr {$V == 2}]]
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_5
    clocals_test10_5
} {{TclString 2} {expr 1} {TclInteger 2}}

test compiledLocals-10.6 {expr} {
    # expr operation inside if command will
    # convert from TclString to TclInteger.
    proc clocals_test10_6 {} {
        set V [string range "2" 0 end]

        set results [list]
        lappend results [irepto $V]
        if {$V == 10} {}
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_6
    clocals_test10_6
} {{TclString 2} {TclInteger 2}}

test compiledLocals-10.7 {expr} {
    # optimized expr operation to query boolean
    # value inside if command will convert
    # from TclString to TclInteger. One might
    # think this would convert to TclBoolean,
    # but the TclInteger internal rep is preferred.
    proc clocals_test10_7 {} {
        set V [string range "1" 0 end]

        set results [list]
        lappend results [irepto $V]
        if {$V} {}
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_7
    clocals_test10_7
} {{TclString 1} {TclInteger 1}}

test compiledLocals-10.8 {expr} {
    # This expr operation will evaluate
    # the TclString value 2 as non-zero
    # and change the internal rep to TclInteger.
    # This command is not compiled.
    proc clocals_test10_8 {} {
        set V [string range "2" 0 end]

        set results [list]
        lappend results [irepto $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_test10_8
} {{TclString 2} 0 OK {TclInteger 2}}

test compiledLocals-10.9 {expr} {
    # This expr operation will see this
    # TclString type as non-zero, so
    # the if true block will be executed.
    proc clocals_test10_9 {} {
        set V [string range "2" 0 end]

        set results [list]
        lappend results [irepto $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_9
    clocals_test10_9
} {{TclString 2} 0 OK {TclInteger 2}}

test compiledLocals-10.10 {expr} {
    # Passing a TclString that contains a
    # double will convert to a TclDouble.
    proc clocals_test10_10 {} {
        set V [string range "2.0" 0 end]

        lappend results [irepto $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_10
    clocals_test10_10
} {{TclString 2.0} 0 OK {TclDouble 2.0}}

test compiledLocals-10.11 {expr} {
    # This format command will convert
    # the TclString into a TclDouble.
    # The optimized if expr should see
    # a non-zero TclDouble as true.
    proc clocals_test10_11 {} {
        set V [string range "2.0" 0 end]

        lappend results [irepto $V]
        format %f $V
        lappend results [irepto $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_11
    clocals_test10_11
} {{TclString 2.0} {TclDouble 2.0} 0 OK {TclDouble 2.0}}

test compiledLocals-10.12 {expr} {
    # Passing a TclString that contains a
    # double will convert to a TclDouble.
    proc clocals_test10_12 {} {
        set V [string range "2.0" 0 end]

        lappend results [irepto $V]
        lappend results [catch {
            if {$V && $V} {
                set r OK
            }
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_12
    clocals_test10_12
} {{TclString 2.0} 0 OK {TclDouble 2.0}}

test compiledLocals-10.13 {expr} {
    # The shared boolean true result
    # is actually an integer with
    # the value 1. It seen as an int
    # by the expr module.
    proc clocals_test10_13 {} {
        set V [string equal "" ""]

        lappend results [irep $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_13
    clocals_test10_13
} {TclInteger 0 OK TclInteger}

test compiledLocals-10.14 {expr} {
    # A TclString that looks like a TclBoolean
    # will not be converted by the expr logic.
    proc clocals_test10_14 {} {
        set V [string range "true" 0 end]

        lappend results [irepto $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_14
    clocals_test10_14
} {{TclString true} 0 OK {TclString true}}

test compiledLocals-10.15 {expr} {
    # A TclList that contains an Integer
    # is reparsed from the string rep and
    # converted to a TclInteger. The irep
    # method is used so that no string rep
    # is generated from the TclList.
    proc clocals_test10_15 {} {
        set i 1
        incr i 0
        set V [list $i]

        lappend results [irep $V]
        lappend results [irepto [lindex $V 0]]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_15
    clocals_test10_15
} {TclList {TclInteger 1} 0 OK TclInteger}

test compiledLocals-10.16 {expr} {
    # A TclList that contains an Integer
    # is reparsed from the string rep and
    # converted to a TclInteger. The irep
    # method is used so that no string rep
    # is generated from the TclList.
    proc clocals_test10_16 {} {
        set i 1
        incr i 0
        set V [list $i]

        lappend results [irep $V]
        lappend results [irepto [lindex $V 0]]
        lappend results [catch {
            if {$V && $V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_16
    clocals_test10_16
} {TclList {TclInteger 1} 0 OK TclInteger}

test compiledLocals-10.17 {expr} {
    # This test used to check that the
    # TclString that was converted to
    # a TclDouble was converted back
    # to a TclInteger in the expr module.
    # That slow logic has not been replaced
    # by changes to the TclDouble module
    # so that a string that can be parsed
    # as both a double and an int will
    # never be converted to a TclDouble
    # internal rep. This change optimizes
    # use of floating point numbers in
    # Jacl's expr command.

    proc clocals_test10_17 {} {
        set V [string range "10" 0 end]

        lappend results [irepto $V]
        format %f $V
        lappend results [irepto $V]
        lappend results [catch {
            expr {$V}
        } err] $err
        lappend results [irepto $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_17
    clocals_test10_17
} {{TclString 10} {TclInteger 10} 0 10 {TclInteger 10}}

test compiledLocals-10.18 {expr} {
    # This TclDouble has no string rep,
    # so the expr layer knows that it can
    # be used without reparsing or checking
    # to see if it is an integer.
    proc clocals_test10_18 {} {
        set V 10.0

        lappend results [irep $V]
        lappend results [catch {
            expr {$V}
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_18
    clocals_test10_18
} {TclDouble 0 10.0 TclDouble}

test compiledLocals-10.19 {expr} {
    # This TclDouble has no string rep,
    # so the optimized boolean expr just
    # uses it.
    proc clocals_test10_19 {} {
        set V 10.0

        lappend results [irep $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_19
    clocals_test10_19
} {TclDouble 0 OK TclDouble}

test compiledLocals-10.20 {expr} {
    # A TclBoolean local var is used by
    # the expr layer without parsing
    # from the string. It is treated
    # as a string value since the
    # string "true" could be used in
    # a string compare expr operation.

    proc clocals_test10_20 {} {
        set V true

        lappend results [irep $V]
        lappend results [catch {
            expr {$V}
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_20
    clocals_test10_20
} {TclBoolean 0 true TclBoolean}

test compiledLocals-10.21 {TclDouble} {
    # This compiled local starts life as TclString.
    # When the format command attempts to convert
    # it to a TclDouble, the internal rep is instead
    # converted to TclInteger. Dealing with numeric
    # conversion logic in the TclInteger and TclDouble
    # class like this means that the expr expression
    # module will not need to scan every TclDouble
    # to see if it looks like an integer.

    proc clocals_test10_21 {} {
        set V [string range "1" 0 end]

        set results [list]
        lappend results [irep $V]
        format %f $V
        lappend results [irep $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_21
    clocals_test10_21
} {TclString TclInteger {expr 1} TclInteger}

test compiledLocals-10.22 {TclDouble} {
    # compiled local starts life as TclInteger,
    # but the format command tries to convert
    # it to a TclDouble. This conversion attempt
    # fails and the number retains the TclInteger
    # internal rep.

    proc clocals_test10_22 {} {
        set V 1

        set results [list]
        lappend results [irep $V]
        format %f $V
        lappend results [irep $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_22
    clocals_test10_22
} {TclInteger TclInteger {expr 1} TclInteger}

test compiledLocals-10.23 {TclDouble} {
    # compiled local starts life as TclInteger,
    # the format command then tries to convert
    # it to a TclDouble. The object can't be
    # converted into a TclDouble internal rep
    # since it looks like an integer. The
    # tricky part here is that the TclDouble.get()
    # method must return the correct parsed
    # value as a double and then not convert
    # to a TclDouble internal rep. The
    # parsed double value does not match
    # the parse integer value in this case.

    proc clocals_test10_23 {} {
        set V 040

        set results [list]
        lappend results [irep $V]
        lappend results [format %0.1f $V]
        lappend results [irep $V]
        lappend results [list "expr" [expr {$V}]]
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_23
    clocals_test10_23
} {TclInteger 40.0 TclInteger {expr 32} TclInteger}

test compiledLocals-10.24 {TclBoolean} {
    # This TclBoolean will be treated as
    # a string value, it will not
    # be parsed as an integer or double.
    proc clocals_test10_24 {} {
        set V true

        lappend results [irep $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_24
    clocals_test10_24
} {TclBoolean 0 OK TclBoolean}

test compiledLocals-10.25 {TclBoolean} {
    # This TclBoolean will be treated as
    # a string value, it will not
    # be parsed as an integer or double.
    proc clocals_test10_25 {} {
        set V false

        lappend results [irep $V]
        lappend results [catch {
            if {!$V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_25
    clocals_test10_25
} {TclBoolean 0 OK TclBoolean}

test compiledLocals-10.26 {TclBoolean} {
    # This TclString could be a TclBoolean,
    # it is treated like any other string
    # by the expr module.
    proc clocals_test10_26 {} {
        set V tru

        lappend results [irep $V]
        lappend results [catch {
            if {$V} {
                set r OK
            }
        } err] $err
        lappend results [irep $V]
        return $results
    }
    clocals_tjc_compiled_proc clocals_test10_26
    clocals_test10_26
} {TclString 0 OK TclString}


# cleanup
catch {unset _clocals_tjc_ready}
catch {rename clocals_test {}}

catch {unset compiled_local_trace_counter}
catch {rename compiled_local_trace_counter {}}

# Try to kill the TJCTread thread in case it is running
java::call tcl.lang.TJCThread terminateThread

::tcltest::cleanupTests
return

