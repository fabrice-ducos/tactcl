test_tjc_init

# Test series 7 is for inlined Tcl command logic.
# builtin Tcl commands like set, global, and
# others are inlined to improve performance
# and reduce code size.
# This is enabled via the +inline-commands
# OPTIONS flag.

# Load jdk test data in case this has not already been done.
source [file join [tcltest::testsDirectory] jdkutils.tcl]
test_jdk_load_config

# Invoked after compileproc_init is invoked inside compileproc_compile.

proc test_compileproc_7_set_flags { proc_name } {
    global _compileproc
    global test_compileproc_7_cache_variables
    global test_compileproc_7_inline_commands
    global test_compileproc_7_skip_constant_increment

    # Inline all containers but don't bother caching commands.
    set _compileproc(options,inline_containers) {all}

    # Set flag if global is set, then unset
    if {[info exists test_compileproc_7_cache_variables]} {
        if {$test_compileproc_7_cache_variables} {
            set _compileproc(options,cache_variables) 1
        }
        unset test_compileproc_7_cache_variables
    }

    # Set flag if global is set, then unset
    if {[info exists test_compileproc_7_inline_commands]} {
        if {$test_compileproc_7_inline_commands} {
            set _compileproc(options,inline_commands) 1
        }
        unset test_compileproc_7_inline_commands
    }

    # Set flag if global is set, then unset
    if {[info exists test_compileproc_7_skip_constant_increment]} {
        if {$test_compileproc_7_skip_constant_increment} {
            set _compileproc(options,skip_constant_increment) 1
        }
        unset test_compileproc_7_skip_constant_increment
    }
}

tcltest::test compileproc7-1.0 {no inline set command} {
    set script {
proc p {} {
    set x
}
}

    set test_compileproc_7_inline_commands 0
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) { initCmd(interp); }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set x
            TclObject[] objv0 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: x
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 2);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("x");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-1.1 {inline set command} {
    set script {
proc p {} {
    set x
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set x
            TclObject tmp0 = interp.getVar("x", null, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-1.2 {inline set command} {
    set script {
proc p {} {
    set x 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set x 1
            TclObject tmp0;
            tmp0 = interp.setVar("x", null, const0, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-1.3 {inline set command} {
    set script {
proc p {} {
    set x $y
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set x $y
            TclObject tmp0;
            tmp0 = interp.getVar("y", null, 0);
            tmp0 = interp.setVar("x", null, tmp0, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-1.4 {inline set command} {
    set script {
proc p {} {
    set x [set y]
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set x [...]
            TclObject tmp0;
            { // Invoke: set y
                TclObject tmp1 = interp.getVar("y", null, 0);
                interp.setResult(tmp1);
            } // End Invoke: set
            tmp0 = interp.getResult();
            tmp0 = interp.setVar("x", null, tmp0, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-1.5 {inline set command, enable varcache} {
    # The variable ::x is a namespace scoped variable name.
    # It needs to be handled with a special init function
    # the will create a link var in the compiled local slot
    # the first time the var is accessed.
    set script {
proc p {} {
    set ::x [set y]
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set ::x [...]
            TclObject tmp0;
            { // Invoke: set y
                TclObject tmp1 = getVarScalar(interp, "y", compiledLocals, 0);
                interp.setResult(tmp1);
            } // End Invoke: set
            tmp0 = interp.getResult();
            initVarScoped(interp, "::x", compiledLocals, 1);
            tmp0 = setVarScalar(interp, "::x", tmp0, compiledLocals, 1);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "y",
        "::x"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.6 {inline set command, enable varcache} {
    set script {
proc p {} {
    set x 1
    set a(one) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set x 1
            TclObject tmp0;
            tmp0 = setVarScalar(interp, "x", const0, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        { // Invoke: set a(one) 1
            TclObject tmp1;
            tmp1 = setVarArray(interp, "a", "one", const0, compiledLocals, 1);
            interp.setResult(tmp1);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "x",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.7 {inline set command, enable varcache} {
    set script {
proc p {} {
    set key one
    set a($key) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set key one
            TclObject tmp0;
            tmp0 = setVarScalar(interp, "key", const0, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        { // Invoke: set a($key) 1
            TclObject tmp1;
            tmp1 = getVarScalar(interp, "key", compiledLocals, 0);
            String tmp2 = tmp1.toString();
            tmp1 = setVarArray(interp, "a", tmp2, const1, compiledLocals, 1);
            interp.setResult(tmp1);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("one");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "key",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.8 {inline set command, enable varcache} {
    set script {
proc p {} {
    set key one
    set a($key)
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set key one
            TclObject tmp0;
            tmp0 = setVarScalar(interp, "key", const0, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        { // Invoke: set a($key)
            TclObject tmp1;
            tmp1 = getVarScalar(interp, "key", compiledLocals, 0);
            String tmp2 = tmp1.toString();
            tmp1 = getVarArray(interp, "a", tmp2, compiledLocals, 1);
            interp.setResult(tmp1);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("one");
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "key",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.9 {inline set command, enable varcache} {
    # A non-static variable name causes this set to not be inlined.
    set script {
proc p {} {
    set $s 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set $s 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 variable: $s
                tmp1 = getVarScalar(interp, "s", compiledLocals, 0);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "s"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.10 {inline set command, enable varcache} {
    # A non-static variable name causes this set to not be inlined.
    set script {
proc p {} {
    set [cmd] 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set [...] 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 command: [...]
                { // Invoke: cmd
                    TclObject[] objv2 = TJC.grabObjv(interp, 1);
                    try {
                        TclObject tmp3;
                        // Arg 0 constant: cmd
                        tmp3 = const1;
                        tmp3.preserve();
                        objv2[0] = tmp3;
                        TJC.invoke(interp, null, objv2, 0);
                    } finally {
                        TJC.releaseObjvElems(interp, objv2, 1);
                    }
                } // End Invoke: cmd
                tmp1 = interp.getResult();
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("cmd");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(1);
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-1.11 {inline set command, enable varcache} {
    # A non-static variable name causes this set to not be inlined.
    set script {
proc p {} {
    set "${s}x${s}" 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set "${s}x${s}" 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 word: "${s}x${s}"
                StringBuffer sbtmp2 = new StringBuffer(64);
                tmp1 = getVarScalar(interp, "s", compiledLocals, 0);
                sbtmp2.append(tmp1.toString());
                sbtmp2.append("x");
                tmp1 = getVarScalar(interp, "s", compiledLocals, 0);
                sbtmp2.append(tmp1.toString());
                tmp1 = TclString.newInstance(sbtmp2);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "s"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.12 {inline set command, enable varcache} {
    # Order of operations check, the variable in the
    # second argument should be evaluated before
    # the third argument.
    set script {
proc p {} {
    set a($key) [cmd]
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set a($key) [...]
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "key", compiledLocals, 0);
            String tmp3 = tmp0.toString();
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            tmp0 = interp.getResult();
            tmp0 = setVarArray(interp, "a", tmp3, tmp0, compiledLocals, 1);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "key",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.13 {inline set command, enable varcache} {
    # Set an array element where a number of word elements
    # need to be concatenated together before the word
    # element is known.
    set script {
proc p {} {
    set a(x${s1}) ""
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set a(x${s1}) ""
            TclObject tmp0;
            String tmp1;
            StringBuffer sbtmp2 = new StringBuffer(64);
            sbtmp2.append("x");
            tmp0 = getVarScalar(interp, "s1", compiledLocals, 0);
            sbtmp2.append(tmp0.toString());
            tmp1 = sbtmp2.toString();
            tmp0 = setVarArray(interp, "a", tmp1, const0, compiledLocals, 1);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "s1",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.14 {inline set command, enable varcache} {
    set script {
proc p {} {
    set a(${s1}[cmd]x) ""
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set a(${s1}[cmd]x) ""
            TclObject tmp0;
            String tmp1;
            StringBuffer sbtmp2 = new StringBuffer(64);
            tmp0 = getVarScalar(interp, "s1", compiledLocals, 0);
            sbtmp2.append(tmp0.toString());
            { // Invoke: cmd
                TclObject[] objv3 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp4;
                    // Arg 0 constant: cmd
                    tmp4 = const1;
                    tmp4.preserve();
                    objv3[0] = tmp4;
                    TJC.invoke(interp, null, objv3, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv3, 1);
                }
            } // End Invoke: cmd
            tmp0 = interp.getResult();
            sbtmp2.append(tmp0.toString());
            sbtmp2.append("x");
            tmp1 = sbtmp2.toString();
            tmp0 = setVarArray(interp, "a", tmp1, const0, compiledLocals, 1);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("cmd");
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "s1",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.15 {inline set command, enable varcache} {
    # This array name is not statically defined, so the
    # set command will not be compiled.
    set script {
proc p {} {
    set ${arr}($key) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set ${arr}($key) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 word: ${arr}($key)
                StringBuffer sbtmp2 = new StringBuffer(64);
                tmp1 = getVarScalar(interp, "arr", compiledLocals, 0);
                sbtmp2.append(tmp1.toString());
                sbtmp2.append("(");
                tmp1 = getVarScalar(interp, "key", compiledLocals, 1);
                sbtmp2.append(tmp1.toString());
                sbtmp2.append(")");
                tmp1 = TclString.newInstance(sbtmp2);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "arr",
        "key"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.16 {inline set command, enable varcache} {
    # This array name is not statically defined, so the
    # set command will not be compiled.
    set script {
proc p {} {
    set ${arr}(elem) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set ${arr}(elem) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 word: ${arr}(elem)
                StringBuffer sbtmp2 = new StringBuffer(64);
                tmp1 = getVarScalar(interp, "arr", compiledLocals, 0);
                sbtmp2.append(tmp1.toString());
                sbtmp2.append("(elem)");
                tmp1 = TclString.newInstance(sbtmp2);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "arr"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.17 {inline set command, enable varcache} {
    # The array name here
    set script {
proc p {} {
    set ::arr(elem) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set ::arr(elem) 1
            TclObject tmp0;
            initVarScoped(interp, "::arr", compiledLocals, 0);
            tmp0 = setVarArray(interp, "::arr", "elem", const0, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "::arr"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.18 {inline set command, enable varcache} {
    set script {
proc p {} {
    set ::arr($key) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set ::arr($key) 1
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "key", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            initVarScoped(interp, "::arr", compiledLocals, 1);
            tmp0 = setVarArray(interp, "::arr", tmp1, const0, compiledLocals, 1);
            interp.setResult(tmp0);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "key",
        "::arr"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.19 {inline set command, enable varcache} {
    # Not a valid array name.
    set script {
proc p {} {
    set a(b)(c) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set a(b)(c) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: a(b)(c)
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("a(b)(c)");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(1);
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-1.20 {inline set command, enable varcache} {
    # Not a valid array name.
    set script {
proc p {} {
    set a(b)($key) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set a(b)($key) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            try {
                TclObject tmp1;
                // Arg 0 constant: set
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 word: a(b)($key)
                StringBuffer sbtmp2 = new StringBuffer(64);
                sbtmp2.append("a(b)(");
                tmp1 = getVarScalar(interp, "key", compiledLocals, 0);
                sbtmp2.append(tmp1.toString());
                sbtmp2.append(")");
                tmp1 = TclString.newInstance(sbtmp2);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 1
                tmp1 = const1;
                tmp1.preserve();
                objv0[2] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 3);
            }
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("set");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "key"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.21 {inline set command, enable varcache} {knownbug} {
    # Unicode escape in array name should not break things
    set script {
proc p {} {
    set a\u0072r($key) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set key one
            TclObject tmp0;
            tmp0 = setVarScalar(interp, "key", const0, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        { // Invoke: set a($key) 1
            TclObject tmp1;
            tmp1 = getVarScalar(interp, "key", compiledLocals, 0);
            tmp1 = setVarArray(interp, "a", tmp1.toString(), const1, compiledLocals, 1);
            interp.setResult(tmp1);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("one");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(1);
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "key",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-1.22 {inline set command, enable varcache} {
    set script {
proc p {} {
    set s "lt"
    set a(resu$s) ""
    set a(result)
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: set s "lt"
            TclObject tmp0;
            tmp0 = setVarScalar(interp, "s", const0, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: set
        { // Invoke: set a(resu$s) ""
            TclObject tmp1;
            String tmp2;
            StringBuffer sbtmp3 = new StringBuffer(64);
            sbtmp3.append("resu");
            tmp1 = getVarScalar(interp, "s", compiledLocals, 0);
            sbtmp3.append(tmp1.toString());
            tmp2 = sbtmp3.toString();
            tmp1 = setVarArray(interp, "a", tmp2, const1, compiledLocals, 1);
            interp.setResult(tmp1);
        } // End Invoke: set
        { // Invoke: set a(result)
            TclObject tmp4 = getVarArray(interp, "a", "result", compiledLocals, 1);
            interp.setResult(tmp4);
        } // End Invoke: set
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("lt");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("");
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "s",
        "a"
    };
} // end class Test1
}}


tcltest::test compileproc7-2.0 {inline global command} {
    set script {
proc p {} {
    global x
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: global x
            interp.resetResult();
            TJC.makeGlobalLinkVar(interp, "x", "x", -1);
        } // End Invoke: global
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-2.1 {inline global command} {
    set script {
proc p {} {
    global x y
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: global x y
            interp.resetResult();
            TJC.makeGlobalLinkVar(interp, "x", "x", 0);
            TJC.makeGlobalLinkVar(interp, "y", "y", 1);
        } // End Invoke: global
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "x",
        "y"
    };
} // end class Test1
}}

tcltest::test compileproc7-2.2 {inline global command} {
    set script {
proc p {} {
    global ::x ::one::two::y
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: global ::x ::one::two::y
            interp.resetResult();
            TJC.makeGlobalLinkVar(interp, "::x", "x", -1);
            TJC.makeGlobalLinkVar(interp, "::one::two::y", "y", -1);
        } // End Invoke: global
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-2.3 {inline global command} {
    # These global commands seem to execute in Tcl, but
    # it is not at all clear what they do. Don't compile
    # them since these operations are not well defined.
    set script {
proc p {} {
    global ARR(FOO)
    global ARR()
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: global ARR(FOO)
            TclObject[] objv0 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp1;
                // Arg 0 constant: global
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: ARR(FOO)
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 2);
            }
        } // End Invoke: global
        { // Invoke: global ARR()
            TclObject[] objv2 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp3;
                // Arg 0 constant: global
                tmp3 = const0;
                tmp3.preserve();
                objv2[0] = tmp3;
                // Arg 1 constant: ARR()
                tmp3 = const2;
                tmp3.preserve();
                objv2[1] = tmp3;
                TJC.invoke(interp, null, objv2, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 2);
            }
        } // End Invoke: global
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("global");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("ARR(FOO)");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("ARR()");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}


tcltest::test compileproc7-3.0 {inline list command} {
    set script {
proc p {} {
    list
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: list
            TclObject tmp0 = TclList.newInstance();
            interp.setResult(tmp0);
        } // End Invoke: list
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-3.1 {inline list command} {
    set script {
proc p {} {
    list 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: list 1
            TclObject tmp0 = TclList.newInstance();
            TclList.append(interp, tmp0, const0);
            interp.setResult(tmp0);
        } // End Invoke: list
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-3.2 {inline list command} {
    set script {
proc p {} {
    list $x
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: list $x
            TclObject tmp0 = TclList.newInstance();
            TclObject tmp1;
            tmp1 = interp.getVar("x", null, 0);
            TclList.append(interp, tmp0, tmp1);
            interp.setResult(tmp0);
        } // End Invoke: list
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-3.3 {inline list command} {
    set script {
proc p {} {
    list $x foo $y
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: list $x foo $y
            TclObject tmp0 = TclList.newInstance();
            TclObject tmp1;
            try {
                tmp1 = interp.getVar("x", null, 0);
                TclList.append(interp, tmp0, tmp1);
                TclList.append(interp, tmp0, const0);
                tmp1 = interp.getVar("y", null, 0);
                TclList.append(interp, tmp0, tmp1);
            } catch (TclException ex) {
                tmp0.release();
                throw ex;
            }
            interp.setResult(tmp0);
        } // End Invoke: list
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("foo");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-3.4 {inline list command} {
    set script {
proc p {} {
    list 1 2 3
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: list 1 2 3
            TclObject tmp0 = TclList.newInstance();
            try {
                TclList.append(interp, tmp0, const0);
                TclList.append(interp, tmp0, const1);
                TclList.append(interp, tmp0, const2);
            } catch (TclException ex) {
                tmp0.release();
                throw ex;
            }
            interp.setResult(tmp0);
        } // End Invoke: list
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(2);
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(3);
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}


tcltest::test compileproc7-4.0 {inline llength command} {
    set script {
proc p {} {
    llength {1 2 3}
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: llength {1 2 3}
            int tmp0 = TclList.getLength(interp, const0);
            interp.setResult(tmp0);
        } // End Invoke: llength
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("1 2 3");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-4.1 {inline llength command} {
    set script {
proc p {} {
    llength $x
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: llength $x
            TclObject tmp0 = interp.getVar("x", null, 0);
            int tmp1 = TclList.getLength(interp, tmp0);
            interp.setResult(tmp1);
        } // End Invoke: llength
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}


tcltest::test compileproc7-5.0 {inline incr command} {
    set script {
proc p {} {
    incr x
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x
            interp.resetResult();
            TclObject tmp0 = TJC.incrVar(interp, "x", null, 1);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-5.1 {inline incr command} {
    set script {
proc p {} {
    incr x 20
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x 20
            interp.resetResult();
            TclObject tmp0 = TJC.incrVar(interp, "x", null, 20);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-5.2 {inline incr command} {
    set script {
proc p {} {
    incr x 0xFF
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x 0xFF
            int tmp0 = TclInteger.get(interp, const0);
            interp.resetResult();
            TclObject tmp1 = TJC.incrVar(interp, "x", null, tmp0);
            interp.setResult(tmp1);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("0xFF");
        TclInteger.get(interp, const0);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-5.3 {inline incr command} {
    set script {
proc p {} {
    incr x $y
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x $y
            TclObject tmp0 = interp.getVar("y", null, 0);
            int tmp1 = TclInteger.get(interp, tmp0);
            interp.resetResult();
            TclObject tmp2 = TJC.incrVar(interp, "x", null, tmp1);
            interp.setResult(tmp2);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-5.4 {inline incr command} {
    set script {
proc p {} {
    incr x(y)
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x(y)
            interp.resetResult();
            TclObject tmp0 = TJC.incrVar(interp, "x(y)", null, 1);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-5.5 {inline incr command} {
    set script {
proc p {} {
    incr x
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x
            interp.resetResult();
            TclObject tmp0 = incrVarScalar(interp, "x", 1, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "x"
    };
} // end class Test1
}}

tcltest::test compileproc7-5.6 {inline incr command} {
    set script {
proc p {} {
    incr x(y)
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x(y)
            interp.resetResult();
            TclObject tmp0 = incrVarArray(interp, "x", "y", 1, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "x"
    };
} // end class Test1
}}

tcltest::test compileproc7-5.7 {inline incr command} {
    set script {
proc p {} {
    incr x $y
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x $y
            TclObject tmp0 = getVarScalar(interp, "y", compiledLocals, 0);
            int tmp1 = TclInteger.get(interp, tmp0);
            interp.resetResult();
            TclObject tmp2 = incrVarScalar(interp, "x", tmp1, compiledLocals, 1);
            interp.setResult(tmp2);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "y",
        "x"
    };
} // end class Test1
}}

tcltest::test compileproc7-5.8 {inline incr command} {
    set script {
proc p {} {
    incr x [cmd]
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x [...]
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            TclObject tmp0 = interp.getResult();
            int tmp3 = TclInteger.get(interp, tmp0);
            interp.resetResult();
            TclObject tmp4 = incrVarScalar(interp, "x", tmp3, compiledLocals, 0);
            interp.setResult(tmp4);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "x"
    };
} // end class Test1
}}

tcltest::test compileproc7-5.9 {inline incr command} {
    set script {
proc p {} {
    incr ::x(y)
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr ::x(y)
            interp.resetResult();
            TclObject tmp0 = incrVarArray(interp, "::x", "y", 1, compiledLocals, 0);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "::x"
    };
} // end class Test1
}}

tcltest::test compileproc7-5.10 {inline incr command} {
    # non-constant array variable name, no compiled locals
    set script {
proc p {} {
    incr x($s)
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x($s)
            TclObject tmp0;
            StringBuffer sbtmp1 = new StringBuffer(64);
            sbtmp1.append("x(");
            tmp0 = interp.getVar("s", null, 0);
            sbtmp1.append(tmp0.toString());
            sbtmp1.append(")");
            tmp0 = TclString.newInstance(sbtmp1);
            String tmp2 = tmp0.toString();
            interp.resetResult();
            tmp0 = TJC.incrVar(interp, tmp2, null, 1);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-5.11 {inline incr command} {
    # non-constant array variable name, with compiled locals
    set script {
proc p {} {
    incr x($s)
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x($s)
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "s", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            interp.resetResult();
            tmp0 = incrVarArray(interp, "x", tmp1, 1, compiledLocals, 1);
            interp.setResult(tmp0);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    String[] compiledLocalsNames = {
        "s",
        "x"
    };
} // end class Test1
}}

tcltest::test compileproc7-5.12 {inline incr command} {
    set script {
proc p {} {
    incr x($s) [cmd]
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x($s) [...]
            TclObject tmp4;
            StringBuffer sbtmp5 = new StringBuffer(64);
            sbtmp5.append("x(");
            tmp4 = interp.getVar("s", null, 0);
            sbtmp5.append(tmp4.toString());
            sbtmp5.append(")");
            tmp4 = TclString.newInstance(sbtmp5);
            String tmp6 = tmp4.toString();
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            TclObject tmp0 = interp.getResult();
            int tmp3 = TclInteger.get(interp, tmp0);
            interp.resetResult();
            tmp4 = TJC.incrVar(interp, tmp6, null, tmp3);
            interp.setResult(tmp4);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-5.13 {inline incr command} {
    set script {
proc p {} {
    incr x($s) [cmd]
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: incr x($s) [...]
            TclObject tmp4;
            tmp4 = getVarScalar(interp, "s", compiledLocals, 0);
            String tmp5 = tmp4.toString();
            { // Invoke: cmd
                TclObject[] objv1 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp2;
                    // Arg 0 constant: cmd
                    tmp2 = const0;
                    tmp2.preserve();
                    objv1[0] = tmp2;
                    TJC.invoke(interp, null, objv1, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv1, 1);
                }
            } // End Invoke: cmd
            TclObject tmp0 = interp.getResult();
            int tmp3 = TclInteger.get(interp, tmp0);
            interp.resetResult();
            tmp4 = incrVarArray(interp, "x", tmp5, tmp3, compiledLocals, 1);
            interp.setResult(tmp4);
        } // End Invoke: incr
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "s",
        "x"
    };
} // end class Test1
}}




tcltest::test compileproc7-6.0 {inline lindex command} {
    set script {
proc p {} {
    lindex {A B C} 0
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lindex {A B C} 0
            TclObject tmp0 = TclList.index(interp, const0, 0);
            if ( tmp0 == null ) {
                interp.resetResult();
            } else {
                interp.setResult(tmp0);
            }
        } // End Invoke: lindex
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A B C");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-6.1 {inline lindex command} {
    set script {
proc p {} {
    lindex $l 0
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lindex $l 0
            TclObject tmp0 = interp.getVar("l", null, 0);
            tmp0 = TclList.index(interp, tmp0, 0);
            if ( tmp0 == null ) {
                interp.resetResult();
            } else {
                interp.setResult(tmp0);
            }
        } // End Invoke: lindex
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-6.2 {inline lindex command} {
    set script {
proc p {} {
    lindex $list $index
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lindex $list $index
            TclObject tmp0 = null;
            TclObject tmp1;
            try {
                tmp0 = interp.getVar("list", null, 0);
                tmp0.preserve();
                tmp1 = interp.getVar("index", null, 0);
                TJC.lindexNonconst(interp, tmp0, tmp1);
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
            }
        } // End Invoke: lindex
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-6.3 {inline lindex command} {
    # Currently, no optimizations are done for "end" or "end-1"
    set script {
proc p {} {
    lindex {A B C} end-1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lindex {A B C} end-1
            TclObject tmp0 = null;
            TclObject tmp1;
            try {
                tmp0 = const0;
                tmp0.preserve();
                tmp1 = const1;
                TJC.lindexNonconst(interp, tmp0, tmp1);
            } finally {
                if ( tmp0 != null ) {
                    tmp0.release();
                }
            }
        } // End Invoke: lindex
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A B C");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("end-1");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-6.4 {no inline for lindex command} {
    # No support for compiled multiple arguments to lindex.
    # This could be optimized by adding a constant list to
    # the constant pool and passing to the runtime proc.
    set script {
proc p {} {
    lindex {A B C} 0 0
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lindex {A B C} 0 0
            TclObject[] objv0 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp1;
                // Arg 0 constant: lindex
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: {A B C}
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: 0
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                // Arg 3 constant: 0
                tmp1 = const2;
                tmp1.preserve();
                objv0[3] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 4);
            }
        } // End Invoke: lindex
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("lindex");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("A B C");
        const1.preserve(); const1.preserve();
        const2 = TclInteger.newInstance(0);
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}


tcltest::test compileproc7-7.0 {inline lappend command} {
    # lappend is only inlined with 3 or more arguments.
    set script {
proc p {} {
    lappend var
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend var
            TclObject[] objv0 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp1;
                // Arg 0 constant: lappend
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: var
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 2);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("lappend");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("var");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-7.1 {inline lappend command} {
    set script {
proc p {} {
    lappend var 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend var 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            try {
                TclObject tmp1;
                // Arg 2 constant: 1
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                interp.resetResult();
                tmp1 = TJC.lappendVar(interp, "var", null, objv0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-7.2 {inline lappend command} {
    # Same as above but skip constant increment for argument
    set script {
proc p {} {
    lappend var 1
}
}

    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend var 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            TclObject tmp1;
            try {
                // Arg 2 constant: 1
                objv0[0] = const0;
                interp.resetResult();
                tmp1 = TJC.lappendVar(interp, "var", null, objv0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjv(interp, objv0, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-7.3 {inline lappend command} {
    # Skip constant increment and use cache variable
    set script {
proc p {} {
    lappend var 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend var 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            TclObject tmp1;
            try {
                // Arg 2 constant: 1
                objv0[0] = const0;
                interp.resetResult();
                tmp1 = lappendVarScalar(interp, "var", objv0, compiledLocals, 0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjv(interp, objv0, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "var"
    };
} // end class Test1
}}

tcltest::test compileproc7-7.4 {inline lappend command} {
    # constant array key, no cache vars
    set script {
proc p {} {
    lappend a(k) 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a(k) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            try {
                TclObject tmp1;
                // Arg 2 constant: 1
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                interp.resetResult();
                tmp1 = TJC.lappendVar(interp, "a(k)", null, objv0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-7.5 {inline lappend command} {
    # constant array key, with cache vars
    set script {
proc p {} {
    lappend a(k) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a(k) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            try {
                TclObject tmp1;
                // Arg 2 constant: 1
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                interp.resetResult();
                tmp1 = lappendVarArray(interp, "a", "k", objv0, compiledLocals, 0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-7.6 {inline lappend command} {
    # constant array with non-constant word key, no cache vars
    set script {
proc p {} {
    lappend a($k) 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a($k) 1
            TclObject tmp0;
            tmp0 = interp.getVar("k", null, 0);
            String tmp1 = tmp0.toString();
            TclObject[] objv2 = TJC.grabObjv(interp, 1);
            try {
                // Arg 2 constant: 1
                tmp0 = const0;
                tmp0.preserve();
                objv2[0] = tmp0;
                interp.resetResult();
                tmp0 = TJC.lappendVar(interp, "a", tmp1, objv2);
                interp.setResult(tmp0);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-7.7 {inline lappend command} {
    # constant array and non-constant word key, with cache vars
    set script {
proc p {} {
    lappend a($k) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a($k) 1
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "k", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject[] objv2 = TJC.grabObjv(interp, 1);
            try {
                // Arg 2 constant: 1
                tmp0 = const0;
                tmp0.preserve();
                objv2[0] = tmp0;
                interp.resetResult();
                tmp0 = lappendVarArray(interp, "a", tmp1, objv2, compiledLocals, 1);
                interp.setResult(tmp0);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "k",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-7.8 {inline lappend command} {
    # non-constant array key, use cache variables
    # and skip constant incr.
    set script {
proc p {} {
    lappend a($k) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a($k) 1
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "k", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject[] objv2 = TJC.grabObjv(interp, 1);
            try {
                // Arg 2 constant: 1
                objv2[0] = const0;
                interp.resetResult();
                tmp0 = lappendVarArray(interp, "a", tmp1, objv2, compiledLocals, 1);
                interp.setResult(tmp0);
            } finally {
                TJC.releaseObjv(interp, objv2, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "k",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-7.9 {inline lappend command} {
    # non-constant array key, use cache variables
    # and skip constant incr.
    set script {
proc p {} {
    lappend a($k) 1 $k
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a($k) 1 $k
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "k", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject[] objv2 = TJC.grabObjv(interp, 2);
            try {
                // Arg 2 constant: 1
                objv2[0] = const0;
                // Arg 3 variable: $k
                tmp0 = getVarScalar(interp, "k", compiledLocals, 0);
                tmp0.preserve();
                objv2[1] = tmp0;
                interp.resetResult();
                tmp0 = lappendVarArray(interp, "a", tmp1, objv2, compiledLocals, 1);
                interp.setResult(tmp0);
            } finally {
                tmp0 = objv2[1];
                if ( tmp0 != null ) {
                    tmp0.release();
                }
                TJC.releaseObjv(interp, objv2, 2);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "k",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-7.10 {inline lappend command} {
    # constant array key, use cache variables
    # and skip constant incr.
    set script {
proc p {} {
    lappend a(k) 1 $k
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend a(k) 1 $k
            TclObject[] objv0 = TJC.grabObjv(interp, 2);
            TclObject tmp1;
            try {
                // Arg 2 constant: 1
                objv0[0] = const0;
                // Arg 3 variable: $k
                tmp1 = getVarScalar(interp, "k", compiledLocals, 0);
                tmp1.preserve();
                objv0[1] = tmp1;
                interp.resetResult();
                tmp1 = lappendVarArray(interp, "a", "k", objv0, compiledLocals, 1);
                interp.setResult(tmp1);
            } finally {
                tmp1 = objv0[1];
                if ( tmp1 != null ) {
                    tmp1.release();
                }
                TJC.releaseObjv(interp, objv0, 2);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "k",
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-7.11 {inline lappend command} {
    # An lappend to a scoped variable name does not init
    # a compiled local slot for the scoped variable.
    # It could, but this use case is not optimized.
    set script {
proc p {} {
    lappend ::v 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: lappend ::v 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            TclObject tmp1;
            try {
                // Arg 2 constant: 1
                objv0[0] = const0;
                interp.resetResult();
                tmp1 = lappendVarScalar(interp, "::v", objv0, compiledLocals, 0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjv(interp, objv0, 1);
            }
        } // End Invoke: lappend
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "::v"
    };
} // end class Test1
}}


tcltest::test compileproc7-8.0 {inline append command} {
    # append is only inlined with 3 or more arguments.
    set script {
proc p {} {
    append var
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append var
            TclObject[] objv0 = TJC.grabObjv(interp, 2);
            try {
                TclObject tmp1;
                // Arg 0 constant: append
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: var
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 2);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("append");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("var");
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-8.1 {inline append command} {
    set script {
proc p {} {
    append var 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append var 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            try {
                TclObject tmp1;
                // Arg 2 constant: 1
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                interp.resetResult();
                tmp1 = TJC.appendVar(interp, "var", null, objv0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-8.2 {inline append command} {
    # Same as above but skip constant increment for argument
    set script {
proc p {} {
    append var 1
}
}

    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append var 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            TclObject tmp1;
            try {
                // Arg 2 constant: 1
                objv0[0] = const0;
                interp.resetResult();
                tmp1 = TJC.appendVar(interp, "var", null, objv0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjv(interp, objv0, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-8.3 {inline append command} {
    # Skip constant increment and use cache variable
    set script {
proc p {} {
    append var "A"
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append var "A"
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            TclObject tmp1;
            try {
                // Arg 2 constant: "A"
                objv0[0] = const0;
                interp.resetResult();
                tmp1 = appendVarScalar(interp, "var", objv0, compiledLocals, 0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjv(interp, objv0, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A");
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "var"
    };
} // end class Test1
}}

tcltest::test compileproc7-8.4 {inline append command} {

# FIXME: This append case shows that for simple strings,
# it might be better to create an inlined append that
# accepted String arguments. We know the items
# are going to be converted to String elements anyway,
# so why not create some append methods that accept
# from 1 to 10 String arguments. That way each element
# being appended would not need to be added to an array.
# Allocation of the TclObject[] array could be avoided,
# and the special case of one item to append could be
# faster. It is kind of wasteful to add a TclObject to
# the constant pool here for "A" and "CD" since they
# can be appended as String objects. This could make
# a big diff in the TJC impl because this is done a lot.

# Would it be possible to mix passing of TclObject values
# and String values? I think not, but everything gets
# converted to a String anyway. Would it be possible to
# just get the StringBuffer inside the object being
# appended to inside the TJC.append() method and then
# insert directly into the StringBuffer? Still how would
# we pass both TclObject and String values from 1 to N?

# void appendElems(TclObject obj, String s1) {
#     StringBuffer b = TclString.breakInto(obj);
#     b.append(s1);
# }

# void appendElems(TclObject obj, String s1, String s2) {
#     StringBuffer b = TclString.breakInto(obj);
#     b.append(s1);
#     b.append(s2);
# }

# The above could would let us keep String arguments
# to append out of the constant pool while still
# avoiding the array allocation.

    # Skip constant increment and use cache variable
    set script {
proc p {} {
    append var "A" $s "CD"
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_skip_constant_increment 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append var "A" $s "CD"
            TclObject[] objv0 = TJC.grabObjv(interp, 3);
            TclObject tmp1;
            try {
                // Arg 2 constant: "A"
                objv0[0] = const0;
                // Arg 3 variable: $s
                tmp1 = getVarScalar(interp, "s", compiledLocals, 0);
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 4 constant: "CD"
                objv0[2] = const1;
                interp.resetResult();
                tmp1 = appendVarScalar(interp, "var", objv0, compiledLocals, 1);
                interp.setResult(tmp1);
            } finally {
                tmp1 = objv0[1];
                if ( tmp1 != null ) {
                    tmp1.release();
                }
                TJC.releaseObjv(interp, objv0, 3);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("CD");
        const1.preserve(); const1.preserve();
    }

    String[] compiledLocalsNames = {
        "s",
        "var"
    };
} // end class Test1
}}

tcltest::test compileproc7-8.5 {inline append command} {
    # static array name, no cache vars
    set script {
proc p {} {
    append a(k) 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append a(k) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            try {
                TclObject tmp1;
                // Arg 2 constant: 1
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                interp.resetResult();
                tmp1 = TJC.appendVar(interp, "a(k)", null, objv0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-8.6 {inline append command} {
    # static array varname, cache vars enabled
    set script {
proc p {} {
    append a(k) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 1, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append a(k) 1
            TclObject[] objv0 = TJC.grabObjv(interp, 1);
            try {
                TclObject tmp1;
                // Arg 2 constant: 1
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                interp.resetResult();
                tmp1 = appendVarArray(interp, "a", "k", objv0, compiledLocals, 0);
                interp.setResult(tmp1);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "a"
    };
} // end class Test1
}}

tcltest::test compileproc7-8.7 {inline append command} {
    # non-static array name, no cache vars
    set script {
proc p {} {
    append a($k) 1
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append a($k) 1
            TclObject tmp0;
            tmp0 = interp.getVar("k", null, 0);
            String tmp1 = tmp0.toString();
            TclObject[] objv2 = TJC.grabObjv(interp, 1);
            try {
                // Arg 2 constant: 1
                tmp0 = const0;
                tmp0.preserve();
                objv2[0] = tmp0;
                interp.resetResult();
                tmp0 = TJC.appendVar(interp, "a", tmp1, objv2);
                interp.setResult(tmp0);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-8.8 {inline append command} {
    # non-static array name, with cache vars
    set script {
proc p {} {
    append a($k) 1
}
}

    set test_compileproc_7_cache_variables 1
    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        Var[] compiledLocals =
            TJC.initCompiledLocals(callFrame, 2, compiledLocalsNames);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: append a($k) 1
            TclObject tmp0;
            tmp0 = getVarScalar(interp, "k", compiledLocals, 0);
            String tmp1 = tmp0.toString();
            TclObject[] objv2 = TJC.grabObjv(interp, 1);
            try {
                // Arg 2 constant: 1
                tmp0 = const0;
                tmp0.preserve();
                objv2[0] = tmp0;
                interp.resetResult();
                tmp0 = appendVarArray(interp, "a", tmp1, objv2, compiledLocals, 1);
                interp.setResult(tmp0);
            } finally {
                TJC.releaseObjvElems(interp, objv2, 1);
            }
        } // End Invoke: append
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(1);
        const0.preserve(); const0.preserve();
    }

    String[] compiledLocalsNames = {
        "k",
        "a"
    };
} // end class Test1
}}



tcltest::test compileproc7-9.0 {inline string command} {
    # string length command
    set script {
proc p {} {
    string length ""
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string length ""
            int tmp0 = const0.toString().length();
            interp.setResult(tmp0);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.1 {inline string command} {
    # string length command
    set script {
proc p {} {
    string length $var
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string length $var
            TclObject tmp0 = interp.getVar("var", null, 0);
            int tmp1 = tmp0.toString().length();
            interp.setResult(tmp1);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-9.2 {inline string command} {
    # string length command : too many args
    set script {
proc p {} {
    string length "" ""
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string length "" ""
            TclObject[] objv0 = TJC.grabObjv(interp, 4);
            try {
                TclObject tmp1;
                // Arg 0 constant: string
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: length
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: ""
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                // Arg 3 constant: ""
                tmp1 = const2;
                tmp1.preserve();
                objv0[3] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 4);
            }
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("string");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("length");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.3 {inline string command} {
    # string index command
    set script {
proc p {} {
    string index "" 0
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string index "" 0
            String tmp0 = const0.toString();
            TclObject tmp1 = TJC.stringIndex(interp, tmp0, const1);
            interp.setResult(tmp1);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(0);
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.4 {inline string command} {
    # string index command
    set script {
proc p {} {
    string index $str $ind
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string index $str $ind
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = interp.getVar("ind", null, 0);
            TclObject tmp3 = TJC.stringIndex(interp, tmp1, tmp2);
            interp.setResult(tmp3);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-9.5 {inline string command} {
    # string compare command
    set script {
proc p {} {
    string compare "" ""
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string compare "" ""
            String tmp0 = const0.toString();
            String tmp1 = const0.toString();
            int tmp2 = tmp0.compareTo(tmp1);
            tmp2 = ((tmp2 > 0) ? 1 : (tmp2 < 0) ? -1 : 0);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.6 {inline string command} {
    # string compare command
    set script {
proc p {} {
    string compare $s1 [cmd]
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string compare $s1 [...]
            TclObject tmp0 = interp.getVar("s1", null, 0);
            String tmp1 = tmp0.toString();
            { // Invoke: cmd
                TclObject[] objv3 = TJC.grabObjv(interp, 1);
                try {
                    TclObject tmp4;
                    // Arg 0 constant: cmd
                    tmp4 = const0;
                    tmp4.preserve();
                    objv3[0] = tmp4;
                    TJC.invoke(interp, null, objv3, 0);
                } finally {
                    TJC.releaseObjvElems(interp, objv3, 1);
                }
            } // End Invoke: cmd
            TclObject tmp2 = interp.getResult();
            String tmp5 = tmp2.toString();
            int tmp6 = tmp1.compareTo(tmp5);
            tmp6 = ((tmp6 > 0) ? 1 : (tmp6 < 0) ? -1 : 0);
            interp.setResult(tmp6);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("cmd");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.7 {inline string command} {
    # string compare command
    set script {
proc p {} {
    string compare -nocase $s1 $s2
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string compare -nocase $s1 $s2
            TclObject[] objv0 = TJC.grabObjv(interp, 5);
            try {
                TclObject tmp1;
                // Arg 0 constant: string
                tmp1 = const0;
                tmp1.preserve();
                objv0[0] = tmp1;
                // Arg 1 constant: compare
                tmp1 = const1;
                tmp1.preserve();
                objv0[1] = tmp1;
                // Arg 2 constant: -nocase
                tmp1 = const2;
                tmp1.preserve();
                objv0[2] = tmp1;
                // Arg 3 variable: $s1
                tmp1 = interp.getVar("s1", null, 0);
                tmp1.preserve();
                objv0[3] = tmp1;
                // Arg 4 variable: $s2
                tmp1 = interp.getVar("s2", null, 0);
                tmp1.preserve();
                objv0[4] = tmp1;
                TJC.invoke(interp, null, objv0, 0);
            } finally {
                TJC.releaseObjvElems(interp, objv0, 5);
            }
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;
    TclObject const2;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("string");
        const0.preserve(); const0.preserve();
        const1 = TclString.newInstance("compare");
        const1.preserve(); const1.preserve();
        const2 = TclString.newInstance("-nocase");
        const2.preserve(); const2.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.8 {inline string command} {
    # string equal command
    set script {
proc p {} {
    string equal "" ""
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string equal "" ""
            String tmp0 = const0.toString();
            String tmp1 = const0.toString();
            boolean tmp2 = tmp0.equals(tmp1);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.9 {inline string command} {
    # string equal command
    set script {
proc p {} {
    string equal $s1 $s2
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string equal $s1 $s2
            TclObject tmp0 = interp.getVar("s1", null, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = interp.getVar("s2", null, 0);
            String tmp3 = tmp2.toString();
            boolean tmp4 = tmp1.equals(tmp3);
            interp.setResult(tmp4);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-9.10 {inline string command} {
    # string range command
    set script {
proc p {} {
    string range "" 0 0
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string range "" 0 0
            String tmp0 = const0.toString();
            TclObject tmp1 = const1;
            tmp1.preserve();
            TclObject tmp2 = const1;
            TclObject tmp3 = TJC.stringRange(interp, tmp0, tmp1, tmp2);
            interp.setResult(tmp3);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(0);
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.11 {inline string command} {
    # string range command
    set script {
proc p {} {
    string range $str $i1 $i2
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string range $str $i1 $i2
            TclObject tmp0 = interp.getVar("str", null, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = interp.getVar("i1", null, 0);
            tmp2.preserve();
            TclObject tmp3 = interp.getVar("i2", null, 0);
            TclObject tmp4 = TJC.stringRange(interp, tmp1, tmp2, tmp3);
            interp.setResult(tmp4);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-9.12 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first "BB" "AABBCC"
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first "BB" "AABBCC"
            String tmp0 = "BB";
            String tmp1 = const0.toString();
            int tmp2 = tmp1.indexOf(tmp0);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("AABBCC");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.13 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first "B" "AABBCC"
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first "B" "AABBCC"
            char tmp0 = 'B';
            String tmp1 = const0.toString();
            int tmp2 = tmp1.indexOf(tmp0);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("AABBCC");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.14 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first "B" "AABBCC" 2
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first "B" "AABBCC" 2
            String tmp0 = "B";
            String tmp1 = const0.toString();
            TclObject tmp2 = TJC.stringFirst(interp, tmp0, tmp1, const1);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("AABBCC");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(2);
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.15 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first "\n" "AABBCC"
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first ... "AABBCC"
            char tmp0 = '\n';
            String tmp1 = const0.toString();
            int tmp2 = tmp1.indexOf(tmp0);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("AABBCC");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.16 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first "" "AABBCC"
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first "" "AABBCC"
            String tmp0 = "";
            String tmp1 = const0.toString();
            TclObject tmp2 = TJC.stringFirst(interp, tmp0, tmp1, null);
            interp.setResult(tmp2);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("AABBCC");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.17 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first $sub "AABBCC"
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first $sub "AABBCC"
            TclObject tmp0 = interp.getVar("sub", null, 0);
            String tmp1 = tmp0.toString();
            String tmp2 = const0.toString();
            TclObject tmp3 = TJC.stringFirst(interp, tmp1, tmp2, null);
            interp.setResult(tmp3);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("AABBCC");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.18 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first $sub $str
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first $sub $str
            TclObject tmp0 = interp.getVar("sub", null, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = interp.getVar("str", null, 0);
            String tmp3 = tmp2.toString();
            TclObject tmp4 = TJC.stringFirst(interp, tmp1, tmp3, null);
            interp.setResult(tmp4);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }
} // end class Test1
}}

tcltest::test compileproc7-9.19 {inline string command} {
    # string first command
    set script {
proc p {} {
    string first $sub $str 2
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string first $sub $str 2
            TclObject tmp0 = interp.getVar("sub", null, 0);
            String tmp1 = tmp0.toString();
            TclObject tmp2 = interp.getVar("str", null, 0);
            String tmp3 = tmp2.toString();
            TclObject tmp4 = TJC.stringFirst(interp, tmp1, tmp3, const0);
            interp.setResult(tmp4);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclInteger.newInstance(2);
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.20 {inline string command} {
    # string last command
    set script {
proc p {} {
    string last "A" $str
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string last "A" $str
            String tmp0 = const0.toString();
            TclObject tmp1 = interp.getVar("str", null, 0);
            String tmp2 = tmp1.toString();
            TclObject tmp3 = TJC.stringLast(interp, tmp0, tmp2, null);
            interp.setResult(tmp3);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.21 {inline string command} {
    # string last command
    set script {
proc p {} {
    string last "A" $str 2
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string last "A" $str 2
            String tmp0 = const0.toString();
            TclObject tmp1 = interp.getVar("str", null, 0);
            String tmp2 = tmp1.toString();
            TclObject tmp3 = TJC.stringLast(interp, tmp0, tmp2, const1);
            interp.setResult(tmp3);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;
    TclObject const1;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A");
        const0.preserve(); const0.preserve();
        const1 = TclInteger.newInstance(2);
        const1.preserve(); const1.preserve();
    }
} // end class Test1
}}

tcltest::test compileproc7-9.22 {inline string command} {
    # string last command
    set script {
proc p {} {
    string last "A" $str $lastInd
}
}

    set test_compileproc_7_inline_commands 1
    set plist [compileproc_script_to_proc_list $script]
    set buffer [compileproc_compile $plist testpkg.Test1 \
        test_compileproc_7_set_flags]
    if {[catch {
    set ok [test_jdk_compile_buffer testpkg.Test1 $buffer]
    }]} {
    set ok NO
    }
    list $ok $buffer
} {OK {// TJC implementation of procedure p
package testpkg;
import tcl.lang.*;

public class Test1 extends TJC.CompiledCommand {
    public void cmdProc(
        Interp interp,
        TclObject[] objv)
            throws TclException
    {
        if (!initCmd) {
            inlineCmds = true;
            initCmd(interp);
        }
        CallFrame callFrame = TJC.pushLocalCallFrame(interp, wcmd.ns);
        try {
        if (objv.length != 1) {
            throw new TclNumArgsException(interp, 1, objv, "");
        }
        { // Invoke: string last "A" $str $lastInd
            String tmp0 = const0.toString();
            TclObject tmp1 = interp.getVar("str", null, 0);
            String tmp2 = tmp1.toString();
            TclObject tmp3 = interp.getVar("lastInd", null, 0);
            TclObject tmp4 = TJC.stringLast(interp, tmp0, tmp2, tmp3);
            interp.setResult(tmp4);
        } // End Invoke: string
        } catch (TclException te) {
            TJC.checkTclException(interp, te, "p");
        } finally {
            TJC.popLocalCallFrame(interp, callFrame);
        }
    }

    TclObject const0;

    protected void initConstants(Interp interp) throws TclException {
        const0 = TclString.newInstance("A");
        const0.preserve(); const0.preserve();
    }
} // end class Test1
}}

# FIXME: In the examples above, it would improve performance if
# the interp result did not need to be set to the result of
# a nested invocation. Perhaps the invocation function could
# be passed a symbol to assign to instead of setting the
# interp result. It would not matter much in the case above,
# but for something like "set x [list 1 2 3]" it could help to
# skip the incr/decr that happens as a result it preserved/released.

# We might also be able to optimize away the interp.resetResult()
# call in cases where we know the interp result is not saved
# or used in a nested  invocation. The current code does not know
# if the result is used while emitting, so it needs to always
# reset or set the result even if it does not get used.

# In many cases, variables are read and then the ref count
# is incremented/decremented. When the compiler knows
# that the method being invoked can't possibly unset
# the variable being passed in, then it should be possible
# to skip the incr()/decr() step for results where a
# ref count is held by the variable.
#
# For example:
#
# set i 0
# set j $i
#
# OR:
#
# [string repeat "ABC" $num], we know the string command,
# is a built-in, so $num would not need to be worried
# about since num would not get unset by this method.
#
#
# If j is an variable that has no traces on it, and i
# is also a variable with no traces, then it should
# be possible to skip the incr/decr for this call.
# It is not really clear how the compiler would know
# that there were no traces, but if none were set
# in the method and no other methods were invoked,
# then the method could be considered "closed" in the
# sense that only inlined operations were being used.
# A compiler result is never skippable, but variables
# should be easier to skip increments for. But this
# set can is not a good example since the inlined
# set command skips the incr anyway.


# Might be really useful to optimize the known basic classes
# like TclInteger, TclList, and so on so that a flag is set
# in the TclObject instance to indicate which type it is.
# This would do an AND to determine if the class was of
# a type instead of using instanceof operator which might
# be slower than just accessing a flag. This kind of check
# is done inside the impl for each type and in the TJC layer,
# so it might provide a worthwhile speedup with only a minor
# complexity addition.

# Cleanup
jdk_tool_cleanup
tcltest::cleanupTests

